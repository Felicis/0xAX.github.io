<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>0xAX blog</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on 0xAX blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 02 Aug 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Introduction to linkers</title>
      <link>http://localhost:1313/blog/2015/08/02/introduction-to-linkers/</link>
      <pubDate>Sun, 02 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/2015/08/02/introduction-to-linkers/</guid>
      <description>

&lt;h2 id=&#34;introduction:850b4ae51b9eca195b5b147f46d55f13&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;During writing of the &lt;a href=&#34;http://0xax.gitbooks.io/linux-insides/content/&#34;&gt;linux-insides&lt;/a&gt; book I have received and continue to receive many emails with the similar questions related with the &lt;a href=&#34;https://en.wikipedia.org/wiki/Linker_%28computing%29&#34;&gt;linker&lt;/a&gt; script and linker related stuff. So&amp;rsquo;ve decided to write this blog post which will cover some aspects related to the linker and linking of object files.&lt;/p&gt;

&lt;p&gt;If we will open page about &lt;code&gt;Linker&lt;/code&gt; on wikipidia, we will see following definition:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;In computer science, a linker or link editor is a computer program that takes one or more object files generated by a compiler and combines them into a single executable file, library file, or another object file.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you&amp;rsquo;ve wrote for example C program in your life you saw with &lt;code&gt;*.o&lt;/code&gt; extension. These files are &lt;a href=&#34;https://en.wikipedia.org/wiki/Object_file&#34;&gt;object files&lt;/a&gt;. Object files are blocks of machine code and data with uncertain addresses of references to data and functions in other object files (or libraries), as well as a list of its own functions and data. The main purpose of the linker is collect/handle code and data of the each object file to the the final executable file or library. In this post we will try to go through all aspects of this process. Let&amp;rsquo;s start.&lt;/p&gt;

&lt;h2 id=&#34;linking-process:850b4ae51b9eca195b5b147f46d55f13&#34;&gt;Linking process&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s create simple project with the following structure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*-linkers
*--main.c
*--lib.c
*--lib.h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And write there for example factorial program. Our &lt;code&gt;main.c&lt;/code&gt; source code file will contain:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

#include &amp;quot;lib.h&amp;quot;

int main(int argc, char **argv) {
	printf(&amp;quot;factorial of 5 is: %d\n&amp;quot;, factorial(5));
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;lib.c&lt;/code&gt; will contain:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;int factorial(int base) {
	int res = 1, i = 1;
	
	if (base == 0) {
		return 1;
	}

	while (i &amp;lt;= base) {
		res *= i;
		i++;
	}

	return res;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the &lt;code&gt;lib.h&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#ifndef LIB_H
#define LIB_H

int factorial(int base);

#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s compile only &lt;code&gt;main.c&lt;/code&gt; source code file with the:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcc -c main.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we will look inside with the &lt;code&gt;nm&lt;/code&gt; util, we will see following output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ nm -A main.o
main.o:                 U factorial
main.o:0000000000000000 T main
main.o:                 U printf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;nm&lt;/code&gt; util allows us to see the list of symbols from the given object file. Look on the its output, it consists from the three columns: the first is the name of the given object file and address of resolved symbols. The second column contains symbol that determines status of the given symbol. In our case the &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt; symbol and the &lt;code&gt;T&lt;/code&gt; is the symbols that placed in the &lt;code&gt;.text&lt;/code&gt; section. So &lt;code&gt;nm&lt;/code&gt; util shows us that we have three symbols in the &lt;code&gt;main.c&lt;/code&gt; source code file:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;factorial&lt;/code&gt; - factorial function that defined in the &lt;code&gt;lib.c&lt;/code&gt; source code file and marked as &lt;code&gt;undefined&lt;/code&gt; because we compile only &lt;code&gt;main.c&lt;/code&gt; source code file and it does not know anything about code from the &lt;code&gt;lib.c&lt;/code&gt; for now;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;main&lt;/code&gt; - main function;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;printf&lt;/code&gt; - function from the &lt;a href=&#34;https://en.wikipedia.org/wiki/GNU_C_Library&#34;&gt;glibc&lt;/a&gt; library and &lt;code&gt;main.c&lt;/code&gt; does not anything about it for now too.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;What we can understand from the output of the &lt;code&gt;nm&lt;/code&gt; for this moment? All is simple. The &lt;code&gt;main.o&lt;/code&gt; object file contains local symbol &lt;code&gt;main&lt;/code&gt; by the &lt;code&gt;0000000000000000&lt;/code&gt; (it will be filled with correct address after the linking) and two unresolved symbols. We can see all of this information in the disassembly output of the &lt;code&gt;main.o&lt;/code&gt; object file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ objdump -S main.o

main.o:     file format elf64-x86-64
Disassembly of section .text:

0000000000000000 &amp;lt;main&amp;gt;:
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	89 7d fc             	mov    %edi,-0x4(%rbp)
   b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
   f:	bf 05 00 00 00       	mov    $0x5,%edi
  14:	e8 00 00 00 00       	callq  19 &amp;lt;main+0x19&amp;gt;
  19:	89 c6                	mov    %eax,%esi
  1b:	bf 00 00 00 00       	mov    $0x0,%edi
  20:	b8 00 00 00 00       	mov    $0x0,%eax
  25:	e8 00 00 00 00       	callq  2a &amp;lt;main+0x2a&amp;gt;
  2a:	b8 00 00 00 00       	mov    $0x0,%eax
  2f:	c9                   	leaveq 
  30:	c3                   	retq   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we are interesting only in the two &lt;code&gt;callq&lt;/code&gt; operations. The two &lt;code&gt;callq&lt;/code&gt; operations contain &lt;code&gt;linker stubs&lt;/code&gt; or in another words function name and offset from it to the next instruction. These stubs will be updated to the real addresses of the functions. We can see these functions names with in the following &lt;code&gt;objdump&lt;/code&gt; output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ objdump -S -r main.o

...
  14:	e8 00 00 00 00       	callq  19 &amp;lt;main+0x19&amp;gt;
			15: R_X86_64_PC32	factorial-0x4
  19:	89 c6                	mov    %eax,%esi
...
  25:	e8 00 00 00 00       	callq  2a &amp;lt;main+0x2a&amp;gt;
			26: R_X86_64_PC32	printf-0x4
  2a:	b8 00 00 00 00       	mov    $0x0,%eax
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;-r&lt;/code&gt; or &lt;code&gt;--reloc&lt;/code&gt; flags of the &lt;code&gt;objdump&lt;/code&gt; util print the &lt;code&gt;relocation&lt;/code&gt; entries of the file. Now let&amp;rsquo;s know a little about relocation process.&lt;/p&gt;

&lt;h2 id=&#34;relocation:850b4ae51b9eca195b5b147f46d55f13&#34;&gt;Relocation&lt;/h2&gt;

&lt;p&gt;Relocation is the process of connecting symbolic references with symbolic definitions. Let&amp;rsquo;s look on the previous snippet from the &lt;code&gt;objdump&lt;/code&gt; output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  14:	e8 00 00 00 00       	callq  19 &amp;lt;main+0x19&amp;gt;
			15: R_X86_64_PC32	factorial-0x4
  19:	89 c6                	mov    %eax,%esi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note &lt;code&gt;e8 00 00 00 00&lt;/code&gt; on the first line. The &lt;code&gt;e8&lt;/code&gt; is the &lt;a href=&#34;https://en.wikipedia.org/wiki/Opcode&#34;&gt;opcode&lt;/a&gt; of the &lt;code&gt;call&lt;/code&gt; instruction with a relative offset. So the &lt;code&gt;e8 00 00 00 00&lt;/code&gt; contains a one-byte operation code followed by a four-byte address. Note that the &lt;code&gt;00 00 00 00&lt;/code&gt; is 4-bytes, but why only 4-bytes if an address can be 8-bytes in the &lt;code&gt;x86_64&lt;/code&gt;. Actually we compiled the &lt;code&gt;main.c&lt;/code&gt; source code file with the &lt;code&gt;-mcmodel=small&lt;/code&gt;. From the &lt;code&gt;gcc&lt;/code&gt; man:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-mcmodel=small
    Generate code for the small code model: the program and its symbols must be linked in the lower 2 GB of the address space. Pointers are 64 bits. Programs can be statically or dynamically linked. This is the default code model.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course we didn&amp;rsquo;t pass this option to the &lt;code&gt;gcc&lt;/code&gt; when we compiled the &lt;code&gt;main.c&lt;/code&gt;, but it is default. We know that our program will be linked in the lower 2 GB of the address space from the quoute from &lt;code&gt;gcc&lt;/code&gt; manual. In this way 4-bytes enough for this. So we have opcode of the &lt;code&gt;call&lt;/code&gt; instruction and unknown address. When we compile &lt;code&gt;main.c&lt;/code&gt; with all dependencies to the executable file and will look on the call of the factorial we will see:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcc main.c lib.c -o factorial | objdump -S factorial | grep factorial

factorial:     file format elf64-x86-64
...
...
0000000000400506 &amp;lt;main&amp;gt;:
	40051a:	e8 18 00 00 00       	callq  400537 &amp;lt;factorial&amp;gt;
...
...
0000000000400537 &amp;lt;factorial&amp;gt;:
	400550:	75 07                	jne    400559 &amp;lt;factorial+0x22&amp;gt;
	400557:	eb 1b                	jmp    400574 &amp;lt;factorial+0x3d&amp;gt;
	400559:	eb 0e                	jmp    400569 &amp;lt;factorial+0x32&amp;gt;
	40056f:	7e ea                	jle    40055b &amp;lt;factorial+0x24&amp;gt;
...
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we can see in the previous output, the address of the &lt;code&gt;main&lt;/code&gt; function is &lt;code&gt;0x0000000000400506&lt;/code&gt;. Why it does not starts from the &lt;code&gt;0x0&lt;/code&gt;? You already can know that standard C program is linked with the &lt;code&gt;glibc&lt;/code&gt; C standard library if the &lt;code&gt;-nostdlib&lt;/code&gt; was not passed to the &lt;code&gt;gcc&lt;/code&gt;. The compiled code for a program includes constructors functions to initialize data in the program when the program is started. These functions need to be called before the program is started or in another words before the &lt;code&gt;main&lt;/code&gt; function is called. To make the initialization and termination functions work, the compiler must output something in the assembler code to cause those functions to be called at the appropriate time. Execution of this program will starts from the code that placed in the special section which is called &lt;code&gt;.init&lt;/code&gt;. We can see it in the beginning of the objdump output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;objdump -S factorial | less

factorial:     file format elf64-x86-64

Disassembly of section .init:

00000000004003a8 &amp;lt;_init&amp;gt;:
  4003a8:       48 83 ec 08             sub    $0x8,%rsp
  4003ac:       48 8b 05 a5 05 20 00    mov    0x2005a5(%rip),%rax        # 600958 &amp;lt;_DYNAMIC+0x1d0&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not that it starts at the &lt;code&gt;0x00000000004003a8&lt;/code&gt; address relative to the &lt;code&gt;glibc&lt;/code&gt; code. We can check it also in the resulted &lt;a href=&#34;https://en.wikipedia.org/wiki/Executable_and_Linkable_Format&#34;&gt;ELF&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ readelf -d factorial | grep \(INIT\)
 0x000000000000000c (INIT)               0x4003a8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, the address of the &lt;code&gt;main&lt;/code&gt; function is the &lt;code&gt;0000000000400506&lt;/code&gt; and it is offset from the &lt;code&gt;.init&lt;/code&gt; section. As we can see from the output, the address of the &lt;code&gt;factorial&lt;/code&gt; function is &lt;code&gt;0x0000000000400537&lt;/code&gt; and binary code for the call of the &lt;code&gt;factorial&lt;/code&gt; function now is &lt;code&gt;e8 18 00 00 00&lt;/code&gt;. We already knwo that &lt;code&gt;e8&lt;/code&gt; is opcode for the &lt;code&gt;call&lt;/code&gt; instruction, the next &lt;code&gt;18 00 00 00&lt;/code&gt; (note that address represented as little endian for the &lt;code&gt;x86_64&lt;/code&gt;, in other words it is &lt;code&gt;00 00 00 18&lt;/code&gt;) is the offset from the &lt;code&gt;callq&lt;/code&gt; to the &lt;code&gt;factorial&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; hex(0x40051a + 0x18 + 0x5) == hex(0x400537)
True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So we add &lt;code&gt;0x18&lt;/code&gt; and &lt;code&gt;0x5&lt;/code&gt; to the address of the &lt;code&gt;call&lt;/code&gt; instruction. The offset is measured from the address of the following instruction. Our call instruction is 5-bytes size - &lt;code&gt;e8 18 00 00 00&lt;/code&gt; and the &lt;code&gt;0x18&lt;/code&gt; is the offset from the next after call instruction to the &lt;code&gt;factorial&lt;/code&gt; function. A compiler generally creates each object file with the program addresses starting at zero. But if a program is created from multiple object files, all of they will be overlapped. Just now we saw a process which called - &lt;code&gt;relocation&lt;/code&gt;. This process assigns load addresses to the various parts of the program, adjusting the code and data in the program to reflect the assigned addresses.&lt;/p&gt;

&lt;p&gt;Ok, now we know a little about linkers and relocation. Time to link our object files and to know more about linkers.&lt;/p&gt;

&lt;h2 id=&#34;gnu-linker:850b4ae51b9eca195b5b147f46d55f13&#34;&gt;GNU linker&lt;/h2&gt;

&lt;p&gt;As you can understand from the title, I will use &lt;a href=&#34;https://en.wikipedia.org/wiki/GNU_linker&#34;&gt;GNU linker&lt;/a&gt; or just &lt;code&gt;ld&lt;/code&gt; in this post. Of course we can use &lt;code&gt;gcc&lt;/code&gt; to link our &lt;code&gt;factorial&lt;/code&gt; project:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcc main.c lib.o -o factorial
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and after it we will get executable file - &lt;code&gt;factorial&lt;/code&gt; as a result:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./factorial 
factorial of 5 is: 120
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But &lt;code&gt;gcc&lt;/code&gt; does not link object files. Instead it uses &lt;code&gt;collect2&lt;/code&gt; which is just wrapper for the &lt;code&gt;GNU ld&lt;/code&gt; linker:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ /usr/lib/gcc/x86_64-linux-gnu/4.9/collect2 --version
collect2 version 4.9.3
/usr/bin/ld --version
GNU ld (GNU Binutils for Debian) 2.25
...
...
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok, we can use gcc and it will produce executable file of our program for us. But let&amp;rsquo;s look how to use &lt;code&gt;GNU ld&lt;/code&gt; linker for the same purpose. First of all let&amp;rsquo;s try to link these object files with the following example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ld main.o lib.o -o factorial
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Try to do it and you will get following error:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ld main.o lib.o -o factorial
ld: warning: cannot find entry symbol _start; defaulting to 00000000004000b0
main.o: In function `main&#39;:
main.c:(.text+0x26): undefined reference to `printf&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we can see two problems:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Linker can&amp;rsquo;t find &lt;code&gt;_start&lt;/code&gt; symbol;&lt;/li&gt;
&lt;li&gt;Linker does not know anything about &lt;code&gt;printf&lt;/code&gt; function.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;First of all let&amp;rsquo;s try to understand what is this &lt;code&gt;_start&lt;/code&gt; entry symbol that appears to be required for our program to run? When I&amp;rsquo;ve started to learn programming I have learned that &lt;code&gt;main&lt;/code&gt; function is the entry point of the program. I think you learned this too :) But actually it is not entry point, there is &lt;code&gt;_start&lt;/code&gt; instead. The &lt;code&gt;_start&lt;/code&gt; symbol defined in the &lt;code&gt;crt1.o&lt;/code&gt; object file. We can find it with the:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ objdump -S /usr/lib/gcc/x86_64-linux-gnu/4.9/../../../x86_64-linux-gnu/crt1.o

/usr/lib/gcc/x86_64-linux-gnu/4.9/../../../x86_64-linux-gnu/crt1.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &amp;lt;_start&amp;gt;:
   0:	31 ed                	xor    %ebp,%ebp
   2:	49 89 d1             	mov    %rdx,%r9
   ...
   ...
   ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and we pass this object file to the &lt;code&gt;ld&lt;/code&gt; command as first argumet (see above). Now let&amp;rsquo;s try to link it and will look on result:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ld /usr/lib/gcc/x86_64-linux-gnu/4.9/../../../x86_64-linux-gnu/crt1.o \
main.o lib.o -o factorial

/usr/lib/gcc/x86_64-linux-gnu/4.9/../../../x86_64-linux-gnu/crt1.o: In function `_start&#39;:
/tmp/buildd/glibc-2.19/csu/../sysdeps/x86_64/start.S:115: undefined reference to `__libc_csu_fini&#39;
/tmp/buildd/glibc-2.19/csu/../sysdeps/x86_64/start.S:116: undefined reference to `__libc_csu_init&#39;
/tmp/buildd/glibc-2.19/csu/../sysdeps/x86_64/start.S:122: undefined reference to `__libc_start_main&#39;
main.o: In function `main&#39;:
main.c:(.text+0x26): undefined reference to `printf&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unfortunately we will see even more errors. We can see here old error about undefined &lt;code&gt;printf&lt;/code&gt; and yet another three undefined references:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__libc_csu_fini&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__libc_csu_init&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__libc_start_main&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;code&gt;_start&lt;/code&gt; symbol defined in the &lt;a href=&#34;https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/x86_64/start.S;h=0d27a38e9c02835ce17d1c9287aa01be222e72eb;hb=HEAD&#34;&gt;sysdeps/x86_64/start.S&lt;/a&gt; assembly file in the &lt;code&gt;glibc&lt;/code&gt; source code. We can find following assembly code lines there:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;mov $__libc_csu_fini, %R8_LP
mov $__libc_csu_init, %RCX_LP
...
call __libc_start_main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we pass address of the entry point to the &lt;code&gt;.init&lt;/code&gt; and &lt;code&gt;.fini&lt;/code&gt; section that contain code that starts to execute when program runned and the code that executes when program terminates. And in the end we see the call of the &lt;code&gt;main&lt;/code&gt; function from our program. These three symbols defined in the &lt;a href=&#34;https://sourceware.org/git/?p=glibc.git;a=blob;f=csu/elf-init.c;hb=1d4bbc54bd4f7d85d774871341b49f4357af1fb7&#34;&gt;csu/elf-init.c&lt;/a&gt; source code file. The following two object files:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;crtn.o&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;crtn.i&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Defines the function prologs/epilogs for the .init and .fini sections (with the &lt;code&gt;_init&lt;/code&gt; and &lt;code&gt;_fini&lt;/code&gt; symbols respectively).&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;crtn.o&lt;/code&gt; object file contains these &lt;code&gt;.init&lt;/code&gt; and &lt;code&gt;.fini&lt;/code&gt; sections:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ objdump -S /usr/lib/gcc/x86_64-linux-gnu/4.9/../../../x86_64-linux-gnu/crtn.o

0000000000000000 &amp;lt;.init&amp;gt;:
   0:	48 83 c4 08          	add    $0x8,%rsp
   4:	c3                   	retq   

Disassembly of section .fini:

0000000000000000 &amp;lt;.fini&amp;gt;:
   0:	48 83 c4 08          	add    $0x8,%rsp
   4:	c3                   	retq   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the &lt;code&gt;crti.o&lt;/code&gt; contains &lt;code&gt;_init&lt;/code&gt; and &lt;code&gt;_fini&lt;/code&gt; symbols. Let&amp;rsquo;s try to link again with these two object files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ld \
/usr/lib/gcc/x86_64-linux-gnu/4.9/../../../x86_64-linux-gnu/crt1.o \
/usr/lib/gcc/x86_64-linux-gnu/4.9/../../../x86_64-linux-gnu/crti.o \
/usr/lib/gcc/x86_64-linux-gnu/4.9/../../../x86_64-linux-gnu/crtn.o main.o lib.o \
-o factorial
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And anyway we will get the same errors. Now we need to pass &lt;code&gt;-lc&lt;/code&gt; option to the &lt;code&gt;ld&lt;/code&gt;. This option will search the standard library in the paths that are pointed in the &lt;code&gt;$LD_LIBRARY_PATH&lt;/code&gt; enviroment variable. Let&amp;rsquo;s try to link again wit the &lt;code&gt;-lc&lt;/code&gt; option:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ld \
/usr/lib/gcc/x86_64-linux-gnu/4.9/../../../x86_64-linux-gnu/crt1.o \
/usr/lib/gcc/x86_64-linux-gnu/4.9/../../../x86_64-linux-gnu/crti.o \
/usr/lib/gcc/x86_64-linux-gnu/4.9/../../../x86_64-linux-gnu/crtn.o main.o lib.o -lc \
-o factorial
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally we will get executable file, but if we will try to run it, we will get strange result:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./factorial 
bash: ./factorial: No such file or directory
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What&amp;rsquo;s the problem here? Let&amp;rsquo;s look on the executable file with the &lt;a href=&#34;https://sourceware.org/binutils/docs/binutils/readelf.html&#34;&gt;readelf&lt;/a&gt; util:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ readelf -l factorial 

Elf file type is EXEC (Executable file)
Entry point 0x4003c0
There are 7 program headers, starting at offset 64

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  PHDR           0x0000000000000040 0x0000000000400040 0x0000000000400040
                 0x0000000000000188 0x0000000000000188  R E    8
  INTERP         0x00000000000001c8 0x00000000004001c8 0x00000000004001c8
                 0x000000000000001c 0x000000000000001c  R      1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                 0x0000000000000610 0x0000000000000610  R E    200000
  LOAD           0x0000000000000610 0x0000000000600610 0x0000000000600610
                 0x00000000000001cc 0x00000000000001cc  RW     200000
  DYNAMIC        0x0000000000000610 0x0000000000600610 0x0000000000600610
                 0x0000000000000190 0x0000000000000190  RW     8
  NOTE           0x00000000000001e4 0x00000000004001e4 0x00000000004001e4
                 0x0000000000000020 0x0000000000000020  R      4
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     10

 Section to Segment mapping:
  Segment Sections...
   00     
   01     .interp 
   02     .interp .note.ABI-tag .hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .text .fini .rodata .eh_frame 
   03     .dynamic .got .got.plt .data 
   04     .dynamic 
   05     .note.ABI-tag 
   06     
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note on the strange line:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  INTERP         0x00000000000001c8 0x00000000004001c8 0x00000000004001c8
                 0x000000000000001c 0x000000000000001c  R      1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;.interp&lt;/code&gt; section in the &lt;code&gt;elf&lt;/code&gt; file holds the path name of a program interpreter or in another words the &lt;code&gt;.interp&lt;/code&gt; section simply contains an &lt;code&gt;ascii&lt;/code&gt; string that is the name of the dynamic linker. The dynamic linker is the part of an Linux that loads and links shared libraries needed by an executable when it is executed, by copying the content of libraries from disk to RAM. As we can see in the output of the &lt;code&gt;readelf&lt;/code&gt; command it placed in the &lt;code&gt;/lib64/ld-linux-x86-64.so.2&lt;/code&gt; for the &lt;code&gt;x86_64&lt;/code&gt;. Now let&amp;rsquo;s add pass &lt;code&gt;-dynamic-linker&lt;/code&gt; option with the path of the &lt;code&gt;ld-linux-x86-64.so.2&lt;/code&gt; to the &lt;code&gt;ld&lt;/code&gt; and will see on the result:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcc -c main.c lib.c

$ ld \
/usr/lib/gcc/x86_64-linux-gnu/4.9/../../../x86_64-linux-gnu/crt1.o \
/usr/lib/gcc/x86_64-linux-gnu/4.9/../../../x86_64-linux-gnu/crti.o \
/usr/lib/gcc/x86_64-linux-gnu/4.9/../../../x86_64-linux-gnu/crtn.o main.o lib.o \
-dynamic-linker /lib64/ld-linux-x86-64.so.2 \
-lc -o factorial
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can run it as normal executable file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./factorial

factorial of 5 is: 120
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It works! With the first line we compile the &lt;code&gt;main.c&lt;/code&gt; and the &lt;code&gt;lib.c&lt;/code&gt; source code files to the object files. We will get the &lt;code&gt;main.o&lt;/code&gt; and the &lt;code&gt;lib.o&lt;/code&gt; after execution of the &lt;code&gt;gcc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ file lib.o main.o
lib.o:  ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped
main.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and after this we link object files of the our program with the needed system object files and libraries. We just saw simple example how to compile and link C program with the &lt;code&gt;gcc&lt;/code&gt; compiler and &lt;code&gt;GNU ld&lt;/code&gt; linker. In this example we have used a couple command line options of the &lt;code&gt;GNU linker&lt;/code&gt;, but it supports much more command line options than &lt;code&gt;-o&lt;/code&gt;, &lt;code&gt;-dynamic-linker&lt;/code&gt; and etc. Moreover &lt;code&gt;GNU ld&lt;/code&gt; has own language that allows to control of the linking process. In the next two paragraps we will look it.&lt;/p&gt;

&lt;h2 id=&#34;useful-command-line-options-of-the-gnu-linker:850b4ae51b9eca195b5b147f46d55f13&#34;&gt;Useful command line options of the GNU linker&lt;/h2&gt;

&lt;p&gt;As I already wrote and as you can see in the manual of the &lt;code&gt;GNU linker&lt;/code&gt;, it has big set of the command line options. We&amp;rsquo;ve seen a couple of options in this post: &lt;code&gt;-o &amp;lt;output&amp;gt;&lt;/code&gt; - that tells &lt;code&gt;ld&lt;/code&gt; to produce an output file called &lt;code&gt;output&lt;/code&gt; as the result of linking, &lt;code&gt;-l&amp;lt;name&amp;gt;&lt;/code&gt; that adds the archive or object file specified by the name, &lt;code&gt;-dynamic-linker&lt;/code&gt; that specifies the name of the dynamic linker. Of course the &lt;code&gt;ld&lt;/code&gt; supports much more command line options, let&amp;rsquo;s look on some of it.&lt;/p&gt;

&lt;p&gt;The first useful command line option is &lt;code&gt;@file&lt;/code&gt;. In this case the &lt;code&gt;file&lt;/code&gt; specifies filename where command line options will be read. For example we can create file with the name &lt;code&gt;linker.ld&lt;/code&gt;, put there our command line arguments from the previous example and execute it with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ld @linker.ld
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next command line option is &lt;code&gt;-b&lt;/code&gt; or &lt;code&gt;--format&lt;/code&gt;. This command line option specifies format of the input object files &lt;code&gt;ELF&lt;/code&gt;, &lt;code&gt;DJGPP/COFF&lt;/code&gt; and etc. There is command line option for the same purpose but for the output file: &lt;code&gt;--oformat=output-format&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The next command line option is &lt;code&gt;--defsym&lt;/code&gt;. Full format of this command line option is the &lt;code&gt;--defsym=symbol=expression&lt;/code&gt;. It allows to create global symbol in the output file containing the absolute address given by expression. We can find following case when this command line option can be useful. For example let&amp;rsquo;s look in the Linux kernel source code and more precisely in the Makefile that related to the kernel decompression for ARM architecture - &lt;a href=&#34;https://github.com/torvalds/linux/blob/master/arch/arm/boot/compressed/Makefile&#34;&gt;arch/arm/boot/compressed/Makefile&lt;/a&gt;. We can find following definition there:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LDFLAGS_vmlinux = --defsym _kernel_bss_size=$(KBSS_SZ)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we already know, it defines the &lt;code&gt;_kernel_bss_size&lt;/code&gt; symbol with the size of the &lt;code&gt;.bss&lt;/code&gt; section in the output file. This symbol will be used in the first &lt;a href=&#34;https://github.com/torvalds/linux/blob/master/arch/arm/boot/compressed/head.S&#34;&gt;assembly file&lt;/a&gt; that will be executed during kernel decompressing:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;ldr r5, =_kernel_bss_size
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next command line options is the &lt;code&gt;-shared&lt;/code&gt; that allows us to create shared library. The &lt;code&gt;-M&lt;/code&gt; or &lt;code&gt;-map &amp;lt;filename&amp;gt;&lt;/code&gt; command line option prints the linking map with the information about symbols. In our case:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ld -M @linker.ld
...
...
...
.text           0x00000000004003c0      0x112
 *(.text.unlikely .text.*_unlikely .text.unlikely.*)
 *(.text.exit .text.exit.*)
 *(.text.startup .text.startup.*)
 *(.text.hot .text.hot.*)
 *(.text .stub .text.* .gnu.linkonce.t.*)
 .text          0x00000000004003c0       0x2a /usr/lib/gcc/x86_64-linux-gnu/4.9/../../../x86_64-linux-gnu/crt1.o
...
...
...
 .text          0x00000000004003ea       0x31 main.o
                0x00000000004003ea                main
 .text          0x000000000040041b       0x3f lib.o
                0x000000000040041b                factorial
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course the &lt;code&gt;GNU linker&lt;/code&gt; support standard command line options: &lt;code&gt;--help&lt;/code&gt; and &lt;code&gt;--version&lt;/code&gt; that print common help of the usage of the &lt;code&gt;ld&lt;/code&gt; and its version. That&amp;rsquo;s all about command line options of the &lt;code&gt;GNU linker&lt;/code&gt;. Of course it is not full set of the command line options support by the &lt;code&gt;ld&lt;/code&gt; util. Full description you can find in the manual of this util.&lt;/p&gt;

&lt;h2 id=&#34;control-language-linker:850b4ae51b9eca195b5b147f46d55f13&#34;&gt;Control Language linker&lt;/h2&gt;

&lt;p&gt;As I wrote previously, the &lt;code&gt;ld&lt;/code&gt; has support of the own language. It accepts Linker Command Language files written in a superset of AT&amp;amp;T&amp;rsquo;s Link Editor Command Language syntax, to provide explicit and total control over the linking process. Let&amp;rsquo;s look on its details.&lt;/p&gt;

&lt;p&gt;With the linker language we can control:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;input files;&lt;/li&gt;
&lt;li&gt;output files;&lt;/li&gt;
&lt;li&gt;file formats&lt;/li&gt;
&lt;li&gt;addresses of sections;&lt;/li&gt;
&lt;li&gt;and etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Usually commands written on linker control language placed in a file that called - linker script. We can pass it to the &lt;code&gt;ld&lt;/code&gt; with the &lt;code&gt;-T&lt;/code&gt; command line option. The main command in the each linker script is the &lt;code&gt;SECTIONS&lt;/code&gt;. Each linker script must contain this command and it determines the &lt;code&gt;map&lt;/code&gt; of the output file. The special variable - &lt;code&gt;.&lt;/code&gt; contains current position of the output. Let&amp;rsquo;s write simple assembly program and will look how we can use linker script to control linking of this program. For example it will be hello world:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;section .data
	msg	db &amp;quot;hello, world!&amp;quot;,`\n`
section .text
	global	_start
_start:
	mov	rax, 1
	mov	rdi, 1
	mov	rsi, msg
	mov	rdx, 14
	syscall
	mov	rax, 60
	mov	rdi, 0
	syscall
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can compile and link it with the:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ nasm -f elf64 -o hello.o hello.asm
$ ld -o hello hello.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our program consists from tw sections: &lt;code&gt;.text&lt;/code&gt; - contains code of the program and &lt;code&gt;.data&lt;/code&gt; - contains initialized variables. Let&amp;rsquo;s write simple linker script and try to link our &lt;code&gt;hello.asm&lt;/code&gt; assembly file with it. Our script is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
 * Linker script for the factorial
 */
OUTPUT(hello) 
OUTPUT_FORMAT(&amp;quot;elf64-x86-64&amp;quot;)
INPUT(hello.o)

SECTIONS
{
	. = 0x200000;
	.text : {
	      *(.text)
	}

	. = 0x400000;
	.data : {
	      *(.data)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On the first three lines you can see comment that written with &lt;code&gt;C&lt;/code&gt; style. After it the &lt;code&gt;OUTPUT&lt;/code&gt; and the &lt;code&gt;OUTPUT_FORMAT&lt;/code&gt; command specifies name of the our executable file and its format. The next command - is &lt;code&gt;INPUT&lt;/code&gt; specfies input file to the &lt;code&gt;ld&lt;/code&gt; linker. After all of this command we can see main &lt;code&gt;SECTIONS&lt;/code&gt; command, as I already wrote each linker script must contain definition of this command. The &lt;code&gt;SECTIONS&lt;/code&gt; command represents set and order of the sections which are will be in the output file. At the beginning of the &lt;code&gt;SECTIONS&lt;/code&gt; command we can see following line &lt;code&gt;. = 0x200000&lt;/code&gt;. I already wrote above that &lt;code&gt;.&lt;/code&gt; command points to the current position of the output. This line says that the code should be loaded at address &lt;code&gt;0x200000&lt;/code&gt; and the line &lt;code&gt;. = 0x400000&lt;/code&gt; says that data section should be loaded at address &lt;code&gt;0x400000&lt;/code&gt;. The second line after the &lt;code&gt;. = 0x200000&lt;/code&gt; defines &lt;code&gt;.text&lt;/code&gt; section as an output section. We can see &lt;code&gt;*(.text)&lt;/code&gt; expression inside it. The &lt;code&gt;*&lt;/code&gt; symbol is wildcard that matches any file name. In another words the &lt;code&gt;*(.text)&lt;/code&gt; expression says all &lt;code&gt;.text&lt;/code&gt; input sections in all input files. We can rewrite it as &lt;code&gt;hello.o(.text)&lt;/code&gt; for our example. After the following location counter &lt;code&gt;. = 0x400000&lt;/code&gt;, we can see definition of the data section.&lt;/p&gt;

&lt;p&gt;We can compile and link it with the:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ nasm  -f elf64 -o hello.o hello.S &amp;amp;&amp;amp; ld -T linker.script &amp;amp;&amp;amp; ./hello
hello, world!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we will look inside with the &lt;code&gt;objdump&lt;/code&gt; util, we will see that &lt;code&gt;.text&lt;/code&gt; section starts from the &lt;code&gt;0x200000&lt;/code&gt; and the &lt;code&gt;.data&lt;/code&gt; sections starts from the &lt;code&gt;0x400000&lt;/code&gt; address:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ objdump -D hello

Disassembly of section .text:

0000000000200000 &amp;lt;_start&amp;gt;:
  200000:	b8 01 00 00 00       	mov    $0x1,%eax
  ...

Disassembly of section .data:

0000000000400000 &amp;lt;msg&amp;gt;:
  400000:	68 65 6c 6c 6f       	pushq  $0x6f6c6c65
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Except of those comands that we have already seen, there are a few other linker scripts commands. The first is the &lt;code&gt;ASSERT(exp, message)&lt;/code&gt; that ensures that given expression is not zero. If it is zero, then exit the linker with an error code and print given error message. If you&amp;rsquo;ve read about Linux kernel booting process in the &lt;a href=&#34;http://0xax.gitbooks.io/linux-insides/content/&#34;&gt;linux-insides&lt;/a&gt; book, you may know that setup header of the Linux kernel has offset - &lt;code&gt;0x1f1&lt;/code&gt;. In the linker script of the Linux kernel we can find check for this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;. = ASSERT(hdr == 0x1f1, &amp;quot;The setup header has the wrong offset!&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next &lt;code&gt;INCLUDE filename&lt;/code&gt; command allows to include external linker script symbols to the current. In a linker script we can assign a value to a symbol. The &lt;code&gt;ld&lt;/code&gt; support a couple of assignment operators:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;symbol = expression   ;&lt;/li&gt;
&lt;li&gt;symbol += expression  ;&lt;/li&gt;
&lt;li&gt;symbol -= expression  ;&lt;/li&gt;
&lt;li&gt;symbol *= expression  ;&lt;/li&gt;
&lt;li&gt;symbol /= expression  ;&lt;/li&gt;
&lt;li&gt;symbol &amp;lt;&amp;lt;= expression ;&lt;/li&gt;
&lt;li&gt;symbol &amp;gt;&amp;gt;= expression ;&lt;/li&gt;
&lt;li&gt;symbol &amp;amp;= expression  ;&lt;/li&gt;
&lt;li&gt;symbol |= expression  ;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As you can note all operators are C assignment operators. For example we can use it in our linker script as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;START_ADDRESS = 0x200000;
DATA_OFFSET   = 0x200000;

SECTIONS
{
	. = START_ADDRESS;
	.text : {
	      *(.text)
	}

	. = START_ADDRESS + DATA_OFFSET;
	.data : {
	      *(.data)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you already may noted the syntax for expressions in the linker script language is identical to that of C expressions. Besides this the control language of the linking supports following builtin functions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ABSOLUTE&lt;/code&gt; - returns absolute value of the given expression;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ADDR&lt;/code&gt; - takes the section and returns its address;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ALIGN&lt;/code&gt; - returns the value of the location counter (&lt;code&gt;.&lt;/code&gt; operator) that aligned by the boundary of the next expression after the given expression;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DEFINED&lt;/code&gt; - returns &lt;code&gt;1&lt;/code&gt; if the given symbol placed in the global symbol table and &lt;code&gt;0&lt;/code&gt; in other way;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MAX&lt;/code&gt; and &lt;code&gt;MIN&lt;/code&gt; - return maximum and minimum of the two given expressions;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NEXT&lt;/code&gt; - returns the next unallocated address that is a multiple of the give expression;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SIZEOF&lt;/code&gt; - returns the size in bytes of the given named section.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That&amp;rsquo;s all.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:850b4ae51b9eca195b5b147f46d55f13&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;This is the end of the post about linkers. We knew many things about linkers in this post, such things like what is it linker and why we need in it, how to use it and etc..&lt;/p&gt;

&lt;p&gt;If you will have any questions or suggestions write me &lt;a href=&#34;kuleshovmail@gmail.com&#34;&gt;email&lt;/a&gt; or ping &lt;a href=&#34;https://twitter.com/0xAX&#34;&gt;me&lt;/a&gt; in twitter.&lt;/p&gt;

&lt;p&gt;Please note that English is not my first language, And I am really sorry for any inconvenience. If you will find any mistakes please send let me know via emal or send a PR to the &lt;a href=&#34;https://github.com/0xAX/0xAX.github.io&#34;&gt;blog&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;links:850b4ae51b9eca195b5b147f46d55f13&#34;&gt;Links&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://0xax.gitbooks.io/linux-insides/content/&#34;&gt;Book about Linux kernel internals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Linker_%28computing%29&#34;&gt;linker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Object_file&#34;&gt;object files&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/GNU_C_Library&#34;&gt;glibc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Opcode&#34;&gt;opcode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Executable_and_Linkable_Format&#34;&gt;ELF&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/GNU_linker&#34;&gt;GNU linker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://0xax.github.io/categories/assembly/&#34;&gt;My posts about assembly programming for x86_64&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sourceware.org/binutils/docs/binutils/readelf.html&#34;&gt;readelf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Say hello to x86_64 Assembly [part 8]</title>
      <link>http://localhost:1313/blog/2014/12/01/say-hello-to-x86_64-assembly-part-8/</link>
      <pubDate>Mon, 01 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/2014/12/01/say-hello-to-x86_64-assembly-part-8/</guid>
      <description>

&lt;p&gt;It is eight and final part of Say hello to x86_64 Assembly and here we will take a look on how to work with non-integer numbers in assembler. There are a couple of ways how to work with floating point data:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;fpu&lt;/li&gt;
&lt;li&gt;sse&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;First of all let&amp;rsquo;s look how floating point number stored in memory. There are three floating point data types:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;single-precision&lt;/li&gt;
&lt;li&gt;double-precision&lt;/li&gt;
&lt;li&gt;double-extended precision&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As Intel&amp;rsquo;s 64-ia-32-architecture-software-developer-vol-1-manual described:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The data formats for these data types correspond directly to formats specified in the IEEE Standard 754 for Binary Floating-Point Arithmetic. 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Single-precision floating-point float point data presented in memory:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sign - 1 bit&lt;/li&gt;
&lt;li&gt;exponent - 8 bits&lt;/li&gt;
&lt;li&gt;mantissa - 23 bits&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So for example if we have following number:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;sign&lt;/th&gt;
&lt;th&gt;exponent&lt;/th&gt;
&lt;th&gt;mantissa&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;00001111&lt;/td&gt;
&lt;td&gt;110000000000000000000000&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Exponent is either an 8 bit signed integer from −128 to 127 or an 8 bit unsigned integer from 0 to 255. Sign bit is zero, so we have positive number. Exponent is 00001111b or 15 in decimal. For single-precision displacement is 127, it means that we need to calculate exponent - 127 or 15 - 127 = -112. Since the normalized binary integer part of the mantissa is always equal to one, then in the mantissa is recorded only its fractional part, so mantissa or our number is 1,110000000000000000000000. Result value will be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;value = mantissa * 2^-112 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Double precision number is 64 bit of memory where:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sign - 1 bit&lt;/li&gt;
&lt;li&gt;exponent - 11 bit&lt;/li&gt;
&lt;li&gt;mantissa - 52 bit&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Result number we can get by:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;value = (-1)^sign * (1 + mantissa / 2 ^ 52) * 2 ^ exponent - 1023) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Extended precision is 80 bit numbers where:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sign - 1 bit&lt;/li&gt;
&lt;li&gt;exponent - 15 bit&lt;/li&gt;
&lt;li&gt;mantissa - 112 bit&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Read more about it - &lt;a href=&#34;https://en.wikipedia.org/wiki/Extended_precision&#34;&gt;here&lt;/a&gt;. Let&amp;rsquo;s look at simple example.&lt;/p&gt;

&lt;h2 id=&#34;x87-fpu:3e92c14d51af847986b077935259e6c4&#34;&gt;x87 FPU&lt;/h2&gt;

&lt;p&gt;The x87 Floating-Point Unit (FPU) provides high-performance floating-point processing. It supports the floating-point, integer, and packed BCD integer data types and the floating-point processing algorithms. x87 provides following instructions set:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Data transfer instructions&lt;/li&gt;
&lt;li&gt;Basic arithmetic instructions&lt;/li&gt;
&lt;li&gt;Comparison instructions&lt;/li&gt;
&lt;li&gt;Transcendental instructions&lt;/li&gt;
&lt;li&gt;Load constant instructions&lt;/li&gt;
&lt;li&gt;x87 FPU control instructions&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Of course we will not see all instructions here provided by x87, for additional information see 64-ia-32-architecture-software-developer-vol-1-manual Chapter 8. There are a couple of data transfer instructions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;FDL&lt;/code&gt; - load floating point&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FST&lt;/code&gt; - store floating point (in ST(0) register)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FSTP&lt;/code&gt; - store floating point and pop (in ST(0) register)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Arithmetic instructions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;FADD&lt;/code&gt; - add floating point&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FIADD&lt;/code&gt; - add integer to floating point&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FSUB&lt;/code&gt; - subtract floating point&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FISUB&lt;/code&gt; - subtract integer from floating point&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FABS&lt;/code&gt; - get absolute value&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FIMUL&lt;/code&gt; - multiply integer and floating point&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FIDIV&lt;/code&gt; - device integer and floating point&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;and etc&amp;hellip; FPU has eight 10 byte registers organized in a ring stack. Top of the stack - register ST(0), other registers are ST(1), ST(2) &amp;hellip; ST(7). We usually uses it when we are working with floating point data. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;section .data
    x dw 1.0
 
fld dword [x]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pushes value of x to this stack. Operator can be 32bit, 64bit or 80bit. It works as usual stack, if we push another value with fld, x value will be in ST(1) and new value will be in ST(0). FPU instructions can use these registers, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;;;
;; adds st0 value to st3 and saves it in st0
;;
fadd st0, st3
 
;;
;; adds x and y and saves it in st0
;;
fld dword [x]
fld dword [y]
fadd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s look on simple example. We will have circle radius and calculate circle square and print it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;extern printResult
 
section .data
		radius    dq  1.7
		result    dq  0
 
		SYS_EXIT  equ 60
		EXIT_CODE equ 0
 
global _start
section .text
 
_start:
		fld qword [radius]
		fld qword [radius]
		fmul
 
		fldpi
		fmul
		fstp qword [result]
 
		mov rax, 0
		movq xmm0, [result]
		call printResult
 
		mov rax, SYS_EXIT
		mov rdi, EXIT_CODE
		syscall
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s try to understand how it works: First of all there is data section with predefined radius data and result which we will use for storing result. After this 2 constants for calling exit system call. Next we see entry point of program - _start. There we stores radius value in st0 and st1 with fld instruction and multiply this two values with fmul instruction. After this operations we will have result of radius on radius multiplication in st0 register. Next we load The number π with fldpi instruction to the st0 register, and after it radius * radius value will be in st1 register. After this execute multiplication with fmul on st0 (pi) and st1 (value of radius * radius), result will be in st0 register. Ok, now we have circle square in st0 register and can extract it with fstp instruction to the result. Next point is to pass result to the C function and call it. Remember we call C function from assembly code in previous blog post. We need to know x86_64 calling convention. In usual way we pass function parameters through registers rdi (arg1), rsi (arg2) and etc&amp;hellip;, but here is floating point data. There is special registers: xmm0 - xmm15 provided by sse. First of all we need to put number of xmmN register to rax register (0 for our case), and put result to xmm0 register. Now we can call C function for printing result:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
 
extern int printResult(double result);
 
int printResult(double result) {
	printf(&amp;quot;Circle radius is - %f\n&amp;quot;, result);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can build it with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;build:
	gcc  -g -c circle_fpu_87c.c -o c.o
	nasm -f elf64 circle_fpu_87.asm -o circle_fpu_87.o
	ld   -dynamic-linker /lib64/ld-linux-x86-64.so.2 -lc circle_fpu_87.o  c.o -o testFloat1
 
clean:
	rm -rf *.o
	rm -rf testFloat1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And run:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://1.bp.blogspot.com/-yBn1V2mJ3no/VJgkuudOQRI/AAAAAAAAAIc/rqVNUpX87Og/s1600/Screenshot%2Bfrom%2B2014-12-22%2B20%3A02%3A56.png&#34; alt=&#34;result&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Say hello to x86_64 Assembly [part 7]</title>
      <link>http://localhost:1313/blog/2014/10/10/say-hello-to-x86_64-assembly-part-7/</link>
      <pubDate>Fri, 10 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/2014/10/10/say-hello-to-x86_64-assembly-part-7/</guid>
      <description>

&lt;p&gt;It is seventh part of Say hello to x86_64 Assembly and here we will look on how we can use C together with assembler.&lt;/p&gt;

&lt;p&gt;Actually we have 3 ways to use it together:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Call assembly routines from C code&lt;/li&gt;
&lt;li&gt;Call c routines from assembly code&lt;/li&gt;
&lt;li&gt;Use inline assembly in C code&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let&amp;rsquo;s write 3 simple Hello world programs which shows us how to use assembly and C together.&lt;/p&gt;

&lt;h2 id=&#34;call-assembly-from-c:7068d9e4e21f24ee49a40f28f2b4b337&#34;&gt;Call assembly from C&lt;/h2&gt;

&lt;p&gt;First of all let&amp;rsquo;s write simple C program like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#include &amp;lt;string.h&amp;gt;
 
int main() {
	char* str = &amp;quot;Hello World\n&amp;quot;;
	int len = strlen(str);
	printHelloWorld(str, len);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we can see C code which defines two variables: our Hello world string which we will write to stdout and length of this string. Next we call printHelloWorld assembly function with this 2 variables as parameters. As we use x86_64 Linux, we must know x86_64 linux calling convetions, so we will know how to write printHelloWorld function, how to get incoming parameters and etc&amp;hellip; When we call function first six parameters passes through rdi, rsi, rdx, rcx, r8 and r9 general purpose registers, all another through the stack. So we can get first and second parameter from rdi and rsi registers and call write syscall and than return from function with ret instruction:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;global printHelloWorld
 
section .text
printHelloWorld:
		;; 1 arg
		mov r10, rdi
		;; 2 arg
		mov r11, rsi
		;; call write syscall
		mov rax, 1
		mov rdi, 1
		mov rsi, r10
		mov rdx, r11
		syscall
		ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can build it with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;build:
	nasm -f elf64 -o casm.o casm.asm
	gcc casm.o casm.c -o casm
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;inline-assembly:7068d9e4e21f24ee49a40f28f2b4b337&#34;&gt;Inline assembly&lt;/h2&gt;

&lt;p&gt;The following method is to write assembly code directly in C code. There is special syntax for this. It has general view:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;asm [volatile] (&amp;quot;assembly code&amp;quot; : output operand : input operand : clobbers);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we can read in gcc documentation volatile keyword means:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The typical use of Extended asm statements is to manipulate input values to produce output values. However, your asm statements may also produce side effects. If so, you may need to use the volatile qualifier to disable certain optimizations
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each operand is described by constraint string followed by C expression in parentheses. There are a number of constraints:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;r&lt;/code&gt; - Kept variable value in general purpose register&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g&lt;/code&gt; - Any register, memory or immediate integer operand is allowed, except for registers that are not general registers.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; - Floating point register&lt;/li&gt;
&lt;li&gt;&lt;code&gt;m&lt;/code&gt; - A memory operand is allowed, with any kind of address that the machine supports in general.&lt;/li&gt;
&lt;li&gt;and etc&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So our hello world will be:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#include &amp;lt;string.h&amp;gt;
 
int main() {
	char* str = &amp;quot;Hello World\n&amp;quot;;
	long len = strlen(str);
	int ret = 0;
 
	__asm__(&amp;quot;movq $1, %%rax \n\t&amp;quot;
		&amp;quot;movq $1, %%rdi \n\t&amp;quot;
		&amp;quot;movq %1, %%rsi \n\t&amp;quot;
		&amp;quot;movl %2, %%edx \n\t&amp;quot;
		&amp;quot;syscall&amp;quot;
		: &amp;quot;=g&amp;quot;(ret)
		: &amp;quot;g&amp;quot;(str), &amp;quot;g&amp;quot; (len));
 
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we can see the same 2 variables as in previous example and inline assembly definition. First of all we put 1 to rax and rdi registers (write system call number, and stdout) as we did it in our plain assembly hello world. Next we do similar operation with rsi and rdi registers but first operands starts with % symbol instead $. It means str is the output operand referred by %1 and len second output operand referred by %2, so we put values of str and len to rsi and rdi with %n notation, where n is number of output operand. Also there is %% prefixed to the register name.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    This helps GCC to distinguish between the operands and registers. operands have a single % as prefix
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can build it with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;build:
	gcc casm.c -o casm
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;call-c-from-assembly:7068d9e4e21f24ee49a40f28f2b4b337&#34;&gt;Call C from assembly&lt;/h2&gt;

&lt;p&gt;And the last method is to call C function from assembly code. For example we have following simple C code with one function which just prints Hello world:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
 
extern int print();
 
int print() {
	printf(&amp;quot;Hello World\n&amp;quot;);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can define this function as extern in our assembly code and call it with call instruction as we do it much times in previous posts:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asssembly&#34;&gt;global _start
 
extern print
 
section .text
 
_start:
		call print
 
		mov rax, 60
		mov rdi, 0
		syscall
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Build it with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;build:
	gcc  -c casm.c -o c.o
	nasm -f elf64 casm.asm -o casm.o
	ld   -dynamic-linker /lib64/ld-linux-x86-64.so.2 -lc casm.o c.o -o casm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and now we can run our third hello world.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Say hello to x86_64 Assembly [part 6]</title>
      <link>http://localhost:1313/blog/2014/10/01/say-hello-to-x86_64-assembly-part-6/</link>
      <pubDate>Wed, 01 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/2014/10/01/say-hello-to-x86_64-assembly-part-6/</guid>
      <description>

&lt;p&gt;It is sixth part of Say hello to x86_64 Assembly and here we will look on AT&amp;amp;T assembler syntax. Previously we used nasm assembler in all parts, but there are some another assemblers with different syntax, fasm, yasm and others. As i wrote above we will look on gas (GNU assembler) and difference between it&amp;rsquo;s syntax and nasm. GCC uses GNU assembler, so if you see at assembler output for simple hello world:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#include &amp;lt;unistd.h&amp;gt;
 
int main(void) {
	write(1, &amp;quot;Hello World\n&amp;quot;, 15);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You will see following output:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;	.file	&amp;quot;test.c&amp;quot;
	.section	.rodata
.LC0:
	.string	&amp;quot;Hello World\n&amp;quot;
	.text
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	$15, %edx
	movl	$.LC0, %esi
	movl	$1, %edi
	call	write
	movl	$0, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.ident	&amp;quot;GCC: (Ubuntu 4.9.1-16ubuntu6) 4.9.1&amp;quot;
	.section	.note.GNU-stack,&amp;quot;&amp;quot;,@progbits
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looks different then nasm Hello world, let&amp;rsquo;s look on some differences.&lt;/p&gt;

&lt;h1 id=&#34;at-t-syntax:23d1702709b33c2ca6b63e660dd5966d&#34;&gt;AT&amp;amp;T syntax&lt;/h1&gt;

&lt;h2 id=&#34;sections:23d1702709b33c2ca6b63e660dd5966d&#34;&gt;Sections&lt;/h2&gt;

&lt;p&gt;I don&amp;rsquo;t know how about you, but when I start to write assembler program, usually I&amp;rsquo;m starting from sections definition. Let&amp;rsquo;s look on simple example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;.data
    //
    // initialized data definition
    //
.text
    .global _start
 
_start:
    //
    // main routine
    //
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can note two little differences here:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Section definition starts with . symbol&lt;/li&gt;
&lt;li&gt;Main routine defines with .globl instead global as we do it in nasm&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Also gas uses another directives for data defintion:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;.section .data
    // 1 byte
    var1: .byte 10
    // 2 byte
    var2: .word 10
    // 4 byte
    var3: .int 10
    // 8 byte
    var4: .quad 10
    // 16 byte
    var5: .octa 10
 
    // assembles each string (with no automatic trailing zero byte) into consecutive addresses
    str1: .asci &amp;quot;Hello world&amp;quot;
    // just like .ascii, but each string is followed by a zero byte
    str2: .asciz &amp;quot;Hello world&amp;quot;
    // Copy the characters in str to the object file
    str3: .string &amp;quot;Hello world&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Operands order
When we write assembler program with nasm, we have following general syntax for data manipulation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;mov destination, source
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With GNU assembler we have back order i.e.:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;mov source, destination
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;;;
;; nasm syntax
;;
mov rax, rcx
 
//
// gas syntax
//
mov %rcx, %rax
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also you can not here that registers starts with % symbol. If you&amp;rsquo;re using direct operands, need to use &lt;code&gt;$&lt;/code&gt; symbol:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;movb $10, %rax
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;size-of-operands-and-operation-syntax:23d1702709b33c2ca6b63e660dd5966d&#34;&gt;Size of operands and operation syntax&lt;/h2&gt;

&lt;p&gt;Sometimes when we need to get part of memory, for example first byte of 64 register, we used following syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;mov ax, word [rsi]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is another way for such operations in gas. We don&amp;rsquo;t define size in operands but in instruction:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;movw (%rsi), %ax
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;GNU assembler has 6 postfixes for operations:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;b&lt;/code&gt; - 1 byte operands&lt;/li&gt;
&lt;li&gt;&lt;code&gt;w&lt;/code&gt; - 2 bytes operands&lt;/li&gt;
&lt;li&gt;&lt;code&gt;l&lt;/code&gt; - 4 bytes operands&lt;/li&gt;
&lt;li&gt;&lt;code&gt;q&lt;/code&gt; - 8 bytes operands&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt; - 10 bytes operands&lt;/li&gt;
&lt;li&gt;&lt;code&gt;o&lt;/code&gt; - 16 bytes operands&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This rule is not only mov instruction, but also for all another like addl, xorb, cmpw and etc&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;memory-access:23d1702709b33c2ca6b63e660dd5966d&#34;&gt;Memory access&lt;/h2&gt;

&lt;p&gt;You can note that we used () brackets in previous example instead [] in nasm example. To dereference values in parentheses are used GAS: (%rax), for example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;movq -8(%rbp),%rdi
movq 8(%rbp),%rdi
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;jumps:23d1702709b33c2ca6b63e660dd5966d&#34;&gt;Jumps&lt;/h2&gt;

&lt;p&gt;GNU assembler supports following operators for far functions call and jumps:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;lcall $section, $offset
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Far jump - a jump to an instruction located in a different segment than the current code segment but at the same privilege level, sometimes referred to as an intersegment jump.&lt;/p&gt;

&lt;h2 id=&#34;comments:23d1702709b33c2ca6b63e660dd5966d&#34;&gt;Comments&lt;/h2&gt;

&lt;p&gt;GNU assembler supports 3 types of comments:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # - single line comments
    // - single line comments
    /* */ - for multiline comments
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Say hello to x86_64 Assembly [part 5]</title>
      <link>http://localhost:1313/blog/2014/09/20/say-hello-to-x86_64-assembly-part-5/</link>
      <pubDate>Sat, 20 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/2014/09/20/say-hello-to-x86_64-assembly-part-5/</guid>
      <description>

&lt;p&gt;It is a fifth part of Say hello to x86_64 Assembly and here we will look at macros. It will not be blog post about x86_64, mainly it will be about nasm assembler and it&amp;rsquo;s preprocessor. If you&amp;rsquo;re interesting in it read next.&lt;/p&gt;

&lt;h2 id=&#34;macros:9760e25cc4f00d95e287bbac1a349ab7&#34;&gt;Macros&lt;/h2&gt;

&lt;p&gt;NASM supports two form of macro:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;single-line&lt;/li&gt;
&lt;li&gt;multiline&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All single-line macro must start from %define directive. It form is following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;%define macro_name(parameter) value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nasm macro behaves and looks very similar as in C. For example, we can create following single-line macro:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;%define argc rsp + 8
%define cliArg1 rsp + 24
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and than use it in code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;;;
;; argc will be expanded to rsp + 8
;;
mov rax, [argc]
cmp rax, 3
jne .mustBe3args
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Multiline macro starts with %macro nasm directive and end with %endmacro. It general form is following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;%macro number_of_parameters
    instruction
    instruction
    instruction
%endmacro
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;%macro bootstrap 1 
          push ebp 
          mov ebp,esp 
%endmacro
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we can use it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;_start: 
    bootstrap
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For example let&amp;rsquo;s look at PRINT macro:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;%macro PRINT 1
    pusha
    pushf
    jmp %%astr
%%str db %1, 0
%%strln equ $-%%str
%%astr: _syscall_write %%str, %%strln
popf
popa
%endmacro 
 
%macro _syscall_write 2
	mov rax, 1
        mov rdi, 1
        mov rsi, %%str
        mov rdx, %%strln
        syscall
%endmacro
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s try to go through it macro and understand how it works: At first line we defined PRINT macro with one parameter. Than we push all general registers (with pusha instruction) and flag register with (with pushf instruction). After this we jump to %%astr label. Pay attention that all labels which defined in macro must start with %%. Now we move to __syscall_write macro with 2 parameter. Let&amp;rsquo;s look on __syscall_write implementation. You can remember that we use write system call in all previous posts for printing string to stdout. It looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;;; write syscall number
mov rax, 1
;; file descriptor, standard output
mov rdi, 1
;; message address
mov rsi, msg
;; length of message
mov rdx, 14
;; call write syscall
syscall
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In our __syscall_write macro we define first two instruction for putting 1 to rax (write system call number) and rdi (stdout file descriptor). Than we put %%str to rsi register (pointer to string), where %%str is local label to which is get first parameter of PRINT macro (pay attention that macro parameter access by $parameter_number) and end with 0 (every string must end with zero). And %%strlen which calculates string length. After this we call system call with syscall instruction and that&amp;rsquo;s all.&lt;/p&gt;

&lt;p&gt;Now we can use it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;label: PRINT &amp;quot;Hello World!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;useful-standard-macros:9760e25cc4f00d95e287bbac1a349ab7&#34;&gt;Useful standard macros&lt;/h2&gt;

&lt;p&gt;NASM supports following standard macros:&lt;/p&gt;

&lt;h2 id=&#34;struc:9760e25cc4f00d95e287bbac1a349ab7&#34;&gt;STRUC&lt;/h2&gt;

&lt;p&gt;We can use &lt;code&gt;STRUC&lt;/code&gt; and &lt;code&gt;ENDSTRUC&lt;/code&gt; for data structure defintion. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;struc person
   name: resb 10
   age:  resb 1
endstruc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now we can make instance of our structure:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;section .data
    p: istruc person
      at name db &amp;quot;name&amp;quot;
      at age  db 25
    iend
 
section .text
_start:
    mov rax, [p + person.name] 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;include:9760e25cc4f00d95e287bbac1a349ab7&#34;&gt;%include&lt;/h2&gt;

&lt;p&gt;We can include other assembly files and jump to there labels or call functions with %include directive.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Say hello to x86_64 Assembly [part 4]</title>
      <link>http://localhost:1313/blog/2014/09/01/say-hello-to-x86_64-assembly-part-4/</link>
      <pubDate>Mon, 01 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/2014/09/01/say-hello-to-x86_64-assembly-part-4/</guid>
      <description>

&lt;p&gt;Some time ago i started to write series of blog posts about assembly programming for x86_64. You can find it by asm tag. Unfortunately i was busy last time and there were not new post, so today I continue to write posts about assembly, and will try to do it every week.&lt;/p&gt;

&lt;p&gt;Today we will look at strings and some strings operations. We still use nasm assembler, and linux x86_64.&lt;/p&gt;

&lt;h2 id=&#34;reverse-string:8818a2798ab83370827e60243d76d259&#34;&gt;Reverse string&lt;/h2&gt;

&lt;p&gt;Of course when we talk about assembly programming language we can&amp;rsquo;t talk about string data type, actually we&amp;rsquo;re dealing with array of bytes. Let&amp;rsquo;s try to write simple example, we will define string data and try to reverse and write result to stdout. This tasks seems pretty simple and popular when we start to learn new programming language. Let&amp;rsquo;s look on implementation.&lt;/p&gt;

&lt;p&gt;First of all, I define initialized data. It will be placed in data section (You can read about sections in part):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;section .data
		SYS_WRITE equ 1
		STD_OUT   equ 1
		SYS_EXIT  equ 60
		EXIT_CODE equ 0
 
		NEW_LINE db 0xa
		INPUT db &amp;quot;Hello world!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we can see four constants:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SYS_WRITE&lt;/code&gt; - &amp;lsquo;write&amp;rsquo; syscall number&lt;/li&gt;
&lt;li&gt;&lt;code&gt;STD_OUT&lt;/code&gt; - stdout file descriptor&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SYS_EXIT&lt;/code&gt; - &amp;lsquo;exit&amp;rsquo; syscall number&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EXIT_CODE&lt;/code&gt; - exit code&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;syscall list you can find - here. Also there defined:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NEW_LINE&lt;/code&gt; - new line (\n) symbol&lt;/li&gt;
&lt;li&gt;&lt;code&gt;INPUT&lt;/code&gt; - our input string, which we will reverse&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Next we define bss section for our buffer, where we will put reversed string:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;section .bss
		OUTPUT resb 12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok we have some data and buffer where to put result, now we can define text section for code. Let&amp;rsquo;s start from main _start routine:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;_start:
		mov rsi, INPUT
		xor rcx, rcx
		cld
		mov rdi, $ + 15
		call calculateStrLength
		xor rax, rax
		xor rdi, rdi
		jmp reverseStr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here are some new things. Let&amp;rsquo;s see how it works: First of all we put INPUT address to si register at line 2, as we did for writing to stdout and write zeros to rcx register, it will be counter for calculating length of our string. At line 4 we can see cld operator. It resets df flag to zero. We need in it because when we will calculate length of string, we will go through symbols of this string, and if df flag will be 0, we will handle symbols of string from left to right. Next we call calculateStrLength function. I missed line 5 with mov rdi, $ + 15 instruction, i will tell about it little later. And now let&amp;rsquo;s look at calculateStrLength implementation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;calculateStrLength:
		;; check is it end of string
		cmp byte [rsi], 0
		;; if yes exit from function
		je exitFromRoutine
		;; load byte from rsi to al and inc rsi
		lodsb
		;; push symbol to stack
		push rax
		;; increase counter
		inc rcx
		;; loop again
		jmp calculateStrLength
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can understand by it&amp;rsquo;s name, it just calculates length of INPUT string and store result in rcx register. First of all we check that rsi register doesn&amp;rsquo;t point to zero, if so this is the end of string and we can exit from function. Next is lodsb instruction. It&amp;rsquo;s simple, it just put 1 byte to al register (low part of 16 bit ax) and changes rsi pointer. As we executed cld instruction, lodsb everytime will move rsi to one byte from left to right, so we will move by string symbols. After it we push rax value to stack, now it contains symbol from our string (lodsb puts byte from si to al, al is low 8 bit of rax). Why we did push symbol to stack? You must remember how stack works, it works by principle LIFO (last input, first output). It is very good for us. We will take first symbol from si, push it to stack, than second and so on. So there will be last symbol of string at the stack top. Than we just pop symbol by symbol from stack and write to OUTPUT buffer. After it we increment our counter (rcx) and loop again to the start of routine.&lt;/p&gt;

&lt;p&gt;Ok, we pushed all symbols from string to stack, now we can jump to exitFromRoutine return to _start there. How to do it? We have ret instruction for this. But if code will be like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;exitFromRoutine:
		;; return to _start
		ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It will not work. Why? It is tricky. Remember we called calculateStrLength at _start. What occurs when we call a function? First of all function&amp;rsquo;s parameters pushes to stack from right to left. After it return address pushes to stack. So function will know where to return after end of execution. But look at calculateStrLength, we pushed symbols from our string to stack and now there is no return address of stack top and function doesn&amp;rsquo;t know where to return. How to be with it. Now we must take a look to the weird instruction before call:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;    mov rdi, $ + 15
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First all:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$&lt;/code&gt; - returns position in memory of string where $ defined&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$$&lt;/code&gt; - returns position in memory of current section start&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So we have position of mov rdi, $ + 15, but why we add 15 here? Look, we need to know position of next line after calculateStrLength. Let&amp;rsquo;s open our file with objdump util:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;objdump -D reverse
 
reverse:     file format elf64-x86-64
 
Disassembly of section .text:
 
00000000004000b0 &amp;lt;_start&amp;gt;:
  4000b0:	48 be 41 01 60 00 00 	movabs $0x600141,%rsi
  4000b7:	00 00 00 
  4000ba:	48 31 c9             	xor    %rcx,%rcx
  4000bd:	fc                   	cld    
  4000be:	48 bf cd 00 40 00 00 	movabs $0x4000cd,%rdi
  4000c5:	00 00 00 
  4000c8:	e8 08 00 00 00       	callq  4000d5 &amp;lt;calculateStrLength&amp;gt;
  4000cd:	48 31 c0             	xor    %rax,%rax
  4000d0:	48 31 ff             	xor    %rdi,%rdi
  4000d3:	eb 0e                	jmp    4000e3 &amp;lt;reverseStr&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can see here that line 12 (our mov rdi, $ + 15) takes 10 bytes and function call at line 16 - 5 bytes, so it takes 15 bytes. That&amp;rsquo;s why our return address will be mov rdi, $ + 15. Now we can push return address from rdi to stack and return from function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;exitFromRoutine:
		;; push return addres to stack again
		push rdi
		;; return to _start
		ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we return to start. After call of the &lt;code&gt;calculateStrLength&lt;/code&gt; we write zeros to rax and rdi and jump to reverseStr label. It&amp;rsquo;s implementation is following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;reverseStr:
		cmp rcx, 0
		je printResult
		pop rax
		mov [OUTPUT + rdi], rax
		dec rcx
		inc rdi
		jmp reverseStr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we check our counter which is length of string and if it is zero we wrote all symbols to buffer and can print it. After checking counter we pop from stack to rax register first symbol and write it to OUTPUT buffer. We add rdi because in other way we&amp;rsquo;ll write symbol to first byte of buffer. After this we increase rdi for moving next by OUTPUT buffer, decrease length counter and jump to the start of label.&lt;/p&gt;

&lt;p&gt;After execution of reverseStr we have reversed string in OUTPUT buffer and can write result to stdout with new line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;printResult:
		mov rdx, rdi
		mov rax, 1
		mov rdi, 1
		mov rsi, OUTPUT
                syscall
		jmp printNewLine
 
printNewLine:
		mov rax, SYS_WRITE
		mov rdi, STD_OUT
		mov rsi, NEW_LINE
		mov rdx, 1
		syscall
		jmp exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and exit from the our program:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;exit:
		mov rax, SYS_EXIT
		mov rdi, EXIT_CODE
		syscall
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s all, now we can compile our program with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;all:
	nasm -g -f elf64 -o reverse.o reverse.asm
	ld -o reverse reverse.o
 
clean:
	rm reverse reverse.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and run it:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://1.bp.blogspot.com/-PoIXmq_sbmU/VG3x4VvtFiI/AAAAAAAAAH4/z2DiEHcrBxs/s1600/Screenshot%2Bfrom%2B2014-11-20%2B19%3A51%3A15.png&#34; alt=&#34;result&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;string-operations:8818a2798ab83370827e60243d76d259&#34;&gt;String operations&lt;/h2&gt;

&lt;p&gt;Of course there are many other instructions for string/bytes manipulations:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;REP&lt;/code&gt; - repeat while rcx is not zero&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MOVSB&lt;/code&gt; - copy a string of bytes (MOVSW, MOVSD and etc..)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CMPSB&lt;/code&gt; - byte string comparison&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SCASB&lt;/code&gt; - byte string scanning&lt;/li&gt;
&lt;li&gt;&lt;code&gt;STOSB&lt;/code&gt; - write byte to string&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Say hello to x86_64 Assembly [part 3]</title>
      <link>http://localhost:1313/blog/2014/08/15/say-hello-to-x86_64-assembly-part-3/</link>
      <pubDate>Fri, 15 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/2014/08/15/say-hello-to-x86_64-assembly-part-3/</guid>
      <description>

&lt;p&gt;The stack is special region in memory, which operates on the principle lifo (Last Input, First Output).&lt;/p&gt;

&lt;p&gt;We have 16 general-purpose registers for temporary data storage. They are RAX, RBX, RCX, RDX, RDI, RSI, RBP, RSP and R8-R15. It&amp;rsquo;s too few for serious applications. So we can store data in the stack. Yet another usage of stack is following: When we call a function, return address copied in stack. After end of function execution, address copied in commands counter (RIP) and application continue to executes from next place after function.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;global _start
 
section .text
 
_start:
		mov rax, 1
		call incRax
		cmp rax, 2
		jne exit
		;;
		;; Do something
		;;
 
incRax:
		inc rax
		ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we can see that after application runnning, rax is equal to 1. Then we call a function incRax, which increases rax value to 1, and now rax value must be 2. After this execution continues from 8 line, where we compare rax value with 2. Also as we can read in &lt;a href=&#34;www.x86-64.org/documentation/abi.pdf&#34;&gt;System V AMD64 ABI&lt;/a&gt;, the first six function arguments passed in registers. They are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rdi&lt;/code&gt; - first argument&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rsi&lt;/code&gt; - second argument&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rdx&lt;/code&gt; - third argument&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rcx&lt;/code&gt; - fourth argument&lt;/li&gt;
&lt;li&gt;&lt;code&gt;r8&lt;/code&gt; - fifth argument&lt;/li&gt;
&lt;li&gt;&lt;code&gt;r9&lt;/code&gt; - sixth&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Next arguments will be passed in stack. So if we have function like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;int foo(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
    return (a1 + a2 - a3 - a4 + a5 - a6) * a7;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then first six arguments will be passed in registers, but 7 argument will be passed in stack.&lt;/p&gt;

&lt;h2 id=&#34;stack-pointer:4eee3c32716a71d8224c9038af3b3484&#34;&gt;Stack pointer&lt;/h2&gt;

&lt;p&gt;As i wroute about we have 16 general-purpose registers, and there are two interesting registers - RSP and RBP. RBP is the base pointer register. It points to the base of the current stack frame. RSP is the stack pointer, which points to the top of current stack frame.&lt;/p&gt;

&lt;p&gt;Commands&lt;/p&gt;

&lt;p&gt;We have two commands for work with stack:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;push argument&lt;/code&gt; - increments stack pointer (RSP) and stores argument in location pointed by stack pointer&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pop argument&lt;/code&gt; - copied data to argument from location pointed by stack pointer&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let&amp;rsquo;s look on one simple example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;global _start
 
section .text
 
_start:
		mov rax, 1
		mov rdx, 2
		push rax
		push rdx
 
		mov rax, [rsp + 8]
 
		;;
		;; Do something
		;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we can see that we put 1 to rax register and 2 to rdx register. After it we push to stack values of these registers. Stack works as LIFO (Last In First Out). So after this stack or our application will have following structure:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://3.bp.blogspot.com/-4H9FAAD2duo/VB0VWfdWJrI/AAAAAAAAAHU/E6BAh0LkDV4/s1600/Untitled%2BDiagram.png&#34; alt=&#34;stack diagram&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Then we copy value from stack which has address rsp + 8. It means we get address of top of stack, add 8 to it and copy data by this address to rax. After it rax value will be 1.&lt;/p&gt;

&lt;h2 id=&#34;example:4eee3c32716a71d8224c9038af3b3484&#34;&gt;Example&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s see one example. We will write simple program, which will get two command line arguments. Will get sum of this arguments and print result.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;section .data
		SYS_WRITE equ 1
		STD_IN    equ 1
		SYS_EXIT  equ 60
		EXIT_CODE equ 0
 
		NEW_LINE   db 0xa
		WRONG_ARGC db &amp;quot;Must be two command line argument&amp;quot;, 0xa
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First of all we define &lt;code&gt;.data&lt;/code&gt; section with some values. Here we have four constants for linux syscalls, for sys_write, sys_exit and etc&amp;hellip; And also we have two strings: First is just new line symbol and second is error message.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look on the &lt;code&gt;.text&lt;/code&gt; section, which consists from code of program:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;section .text
        global _start
 
_start:
		pop rcx
		cmp rcx, 3
		jne argcError
 
		add rsp, 8
		pop rsi
		call str_to_int
 
		mov r10, rax
		pop rsi
		call str_to_int
		mov r11, rax
 
		add r10, r11
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s try to understand, what is happening here: After _start label first instruction get first value from stack and puts it to rcx register. If we run application with command line arguments, all of their will be in stack after running in following order:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    [rsp] - top of stack will contain arguments count.
    [rsp + 8] - will contain argv[0]
    [rsp + 16] - will contain argv[1]
    and so on...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So we get command line arguments count and put it to rcx. After it we compare rcx with 3. And if they are not equal we jump to argcError label which just prints error message:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;argcError:
    ;; sys_write syscall
    mov     rax, 1
    ;; file descritor, standard output
	mov     rdi, 1
    ;; message address
    mov     rsi, WRONG_ARGC
    ;; length of message
    mov     rdx, 34
    ;; call write syscall
    syscall
    ;; exit from program
	jmp exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Why we compare with 3 when we have two arguments. It&amp;rsquo;s simple. First argument is a program name, and all after it are command line arguments which we passed to program. Ok, if we passed two command line arguments we go next to 10 line. Here we shift rsp to 8 and thereby missing the first argument - the name of the program. Now rsp points to first command line argument which we passed. We get it with pop command and put it to rsi register and call function for converting it to integer. Next we read about &lt;code&gt;str_to_int&lt;/code&gt; implementation. After our function ends to work we have integer value in rax register and we save it in r10 register. After this we do the same operation but with r11. In the end we have two integer values in r10 and r11 registers, now we can get sum of it with add command. Now we must convert result to string and print it. Let&amp;rsquo;s see how to do it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;mov rax, r10
;; number counter
xor r12, r12
;; convert to string
jmp int_to_str
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we put sum of command line arguments to rax register, set r12 to zero and jump to int_to_str. Ok now we have base of our program. We already know how to print string and we have what to print. Let&amp;rsquo;s see at str_to_int and int_to_str implementation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;str_to_int:
            xor rax, rax
            mov rcx,  10
next:
	    cmp [rsi], byte 0
	    je return_str
	    mov bl, [rsi]
            sub bl, 48
	    mul rcx
	    add rax, rbx
	    inc rsi
	    jmp next
 
return_str:
	    ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At the start of str_to_int, we set up rax to 0 and rcx to 10. Then we go to next label. As you can see in above example (first line before first call of str_to_int) we put argv[1] in rsi from stack. Now we compare first byte of rsi with 0, because every string ends with NULL symbol and if it is we return. If it is not 0 we copy it&amp;rsquo;s value to one byte bl register and substract 48 from it. Why 48? All numbers from 0 to 9 have 48 to 57 codes in asci table. So if we substract from number symbol 48 (for example from 57) we get number. Then we multiply rax on rcx (which has value - 10). After this we increment rsi for getting next byte and loop again. Algorthm is simple. For example if rsi points to &amp;lsquo;5&amp;rsquo; &amp;lsquo;7&amp;rsquo; &amp;lsquo;6&amp;rsquo; &amp;lsquo;\000&amp;rsquo; sequence, then will be following steps:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rax = 0
    get first byte - 5 and put it to rbx
    rax * 10 --&amp;gt; rax = 0 * 10
    rax = rax + rbx = 0 + 5
    Get second byte - 7 and put it to rbx
    rax * 10 --&amp;gt; rax = 5 * 10 = 50
    rax = rax + rbx = 50 + 7 = 57
    and loop it while rsi is not \000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After str_to_int we will have number in rax. Now let&amp;rsquo;s look at int_to_str:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;int_to_str:
		mov rdx, 0
		mov rbx, 10
		div rbx
		add rdx, 48
		add rdx, 0x0
		push rdx
		inc r12
		cmp rax, 0x0
		jne int_to_str
		jmp print
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we put 0 to rdx and 10 to rbx. Than we exeute div rbx. If we look above at code before str_to_int call. We will see that rax contains integer number - sum of two command line arguments. With this instruction we devide rax value on rbx value and get reminder in rdx and whole part in rax. Next we add to rdx 48 and 0x0. After adding 48 we&amp;rsquo;ll get asci symbol of this number and all strings much be ended with 0x0. After this we save symbol to stack, increment r12 (it&amp;rsquo;s 0 at first iteration, we set it to 0 at the _start) and compare rax with 0, if it is 0 it means that we ended to convert integer to string. Algorithm step by step is following: For example we have number 23&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    123 / 10. rax = 12; rdx = 3
    rdx + 48 = &amp;quot;3&amp;quot;
    push &amp;quot;3&amp;quot; to stack
    compare rax with 0 if no go again
    12 / 10. rax = 1; rdx = 2
    rdx + 48 = &amp;quot;2&amp;quot;
    push &amp;quot;2&amp;quot; to stack
    compare rax with 0, if yes we can finish function execution and we will have &amp;quot;2&amp;quot; &amp;quot;3&amp;quot; ... in stack
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We implemented two useful function &lt;code&gt;int_to_str&lt;/code&gt; and &lt;code&gt;str_to_int&lt;/code&gt; for converting integer number to string and vice versa. Now we have sum of two integers which was converted into string and saved in the stack. We can print result:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;print:
	;;;; calculate number length
	mov rax, 1
	mul r12
	mov r12, 8
	mul r12
	mov rdx, rax
 
	;;;; print sum
	mov rax, SYS_WRITE
	mov rdi, STD_IN
	mov rsi, rsp
	;; call sys_write
	syscall

    jmp exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We already know how to print string with &lt;code&gt;sys_write&lt;/code&gt; syscall, but here is one interesting part. We must to calculate length of string. If you will look on the &lt;code&gt;int_to_str&lt;/code&gt;, you will see that we increment r12 register every iteration, so it contains amount of digits in our number. We must multiple it to 8 (because we pushed every symbol to stack) and it will be length of our string which need to print. After this we as everytime put 1 to rax (sys_write number), 1 to rdi (stdin), string length to rdx and pointer to the top of stack to rsi (start of string). And finish our program:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;exit:
	mov rax, SYS_EXIT
	exit code
	mov rdi, EXIT_CODE
	syscall
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s All.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Say hello to x86_64 Assembly [part 2]</title>
      <link>http://localhost:1313/blog/2014/08/10/say-hello-to-x86_64-assembly-part-2/</link>
      <pubDate>Sun, 10 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/2014/08/10/say-hello-to-x86_64-assembly-part-2/</guid>
      <description>

&lt;p&gt;Some days ago I wrote the first blog post - introduction to x64 assembly - Say hello to x64 Assembly [part 1] which to my surprise caused great interest:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://2.bp.blogspot.com/-wtVOF9PoT3U/VAXLYjlkbbI/AAAAAAAAAGs/Wo-53TGH0Do/s1600/Screenshot%2Bfrom%2B2014-08-31%2B23%3A58%3A26.png&#34; alt=&#34;newscombinator&#34; /&gt;
&lt;img src=&#34;http://4.bp.blogspot.com/-__MfY5bYax4/VAXLf8lQmGI/AAAAAAAAAG0/MBdT2vjhcts/s1600/Screenshot%2Bfrom%2B2014-09-01%2B00%3A30%3A32.png&#34; alt=&#34;reddit&#34; /&gt;&lt;/p&gt;

&lt;p&gt;It motivates me even more to describe my way of learning. During this days I got many feedback from different people. There were many grateful words, but what is more important for me, there were many advices and adequate critics. Especially I want to say thank you words for great feedback to:&lt;/p&gt;

&lt;p&gt;It motivates me even more to describe my way of learning. During this days I got many feedback from different people. There were many grateful words, but what is more important for me, there were many advices and adequate critics. Especially I want to say thank you words for great feedback to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.reddit.com/user/Fiennes&#34;&gt;Fiennes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://disqus.com/by/Universal178/&#34;&gt;Grienders&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://news.ycombinator.com/user?id=nkurz&#34;&gt;nkurz&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And all who took a part in discussion at Reddit and Hacker News. There were many opinions, that first part was a not very clear for absolute beginner, that&amp;rsquo;s why i decided to write more informative posts. So, let&amp;rsquo;s start with second part of Say hello to x86_64 assembly.&lt;/p&gt;

&lt;h2 id=&#34;terminology-and-concepts:ab55faf63a1e5e0b7697868e1403e0f7&#34;&gt;Terminology and Concepts&lt;/h2&gt;

&lt;p&gt;As i wrote above, I got many feedback from different people that some parts of first post are not clear, that&amp;rsquo;s why let&amp;rsquo;s start from description of some terminology that we will see in this and next parts.&lt;/p&gt;

&lt;p&gt;Register - register is a small amount of storage inside processor. Main point of processor is data processing. Processor can get data from memory, but it is slow operation. That&amp;rsquo;s why processor has own internal restricted set of data storage which name is - register.&lt;/p&gt;

&lt;p&gt;Little-endian - we can imagine memory as one large array. It contains bytes. Each address stores one element of the memory &amp;ldquo;array&amp;rdquo;. Each element is one byte. For example we have 4 bytes: AA 56 AB FF. In little-endian the least significant byte has the smallest address:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    0 FF
    1 AB
    2 56
    3 AA 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where 0,1,2 and 3 are memory addresses.&lt;/p&gt;

&lt;p&gt;Big-endian - big-endian stores bytes in opposite order than little-endian. So if we have AA 56 AB FF bytes sequence it will be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    0 AA
    1 56
    2 AB
    3 FF 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Syscall - is the way a user level program asks the operating system to do something for it. You can find syscall table - here. Stack - processor has a very restricted count of registers. So stack is a continuous area of ​​memory addressable special registers RSP,SS,RIP and etc&amp;hellip; We will take a closer look on stack in next parts.&lt;/p&gt;

&lt;p&gt;Section - every assembly program consists from sections. There are following sections:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;data&lt;/code&gt; - section is used for declaring initialized data or constants&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bss&lt;/code&gt; - section is used for declaring non initialized variables&lt;/li&gt;
&lt;li&gt;&lt;code&gt;text&lt;/code&gt; - section is used for code&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;General-purpose registers - there are 16 general-purpose registers - rax, rbx, rcx, rdx, rbp, rsp, rsi, rdi, r8, r9, r10, r11, r12, r13, r14, r15. Of course, it is not a full list of terms and concepts which related with assembly programming. If we will meet another strange and unfamiliar words in next blog posts, there will be explanation of this words.&lt;/p&gt;

&lt;h2 id=&#34;data-types:ab55faf63a1e5e0b7697868e1403e0f7&#34;&gt;Data Types&lt;/h2&gt;

&lt;p&gt;The fundamental data types are bytes, words, doublewords, quadwords, and double quadwords. A byte is eight bits, a word is 2 bytes, a doubleword is 4 bytes, a quadword is 8 bytes and a double quadword is 16 bytes (128 bits).&lt;/p&gt;

&lt;p&gt;Now we will work only with integer numbers, so let&amp;rsquo;s see to it. There two types of integer: unsigned and signed. Unsigned integers are unsigned binary numbers contained in a byte, word, doubleword, and quadword. Their values range from 0 to 255 for an unsigned byte integer, from 0 to 65,535 for an unsigned word integer, from 0 to 2^32 – 1 for an unsigned doubleword integer, and from 0 to 2^64 – 1 for an unsigned quadword integer. Signed integers are signed binary numbers held as unsigned in a byte, word and etc&amp;hellip; The sign bit is set for negative integers and cleared for positive integers and zero. Integer values range from –128 to +127 for a byte integer, from –32,768 to +32,767 for a word integer,from –2^31 to +2^31 – 1 for a doubleword integer, and from –2^63 to +2^63 – 1 for a quadword integer.&lt;/p&gt;

&lt;h2 id=&#34;sections:ab55faf63a1e5e0b7697868e1403e0f7&#34;&gt;Sections&lt;/h2&gt;

&lt;p&gt;As i wrote above, every assembly program consists from sections, it can be data section, text section and bss section. Let&amp;rsquo;s look on data section.It&amp;rsquo;s main point - to declare initialized constants. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;section .data
    num1:   equ 100
    num2:   equ 50
    msg:    db &amp;quot;Sum is correct&amp;quot;, 10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok, it is almost all clear here. 3 constants with name num1, num2, msg and with values 100, 50 and &amp;ldquo;Sum is correct&amp;rdquo;, 10. But what is it db, equ? Actual NASM supports a number of pseudo-instructions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;DB, DW, DD, DQ, DT, DO, DY and DZ - are used for declaring initialized data. For example:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;;; Initialize 4 bytes 1h, 2h, 3h, 4h
db 0x01,0x02,0x03,0x04
 
;; Initialize word to 0x12 0x34
dw    0x1234               
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;RESB, RESW, RESD, RESQ, REST, RESO, RESY and RESZ - are used for declaring non initialized variables&lt;/li&gt;
&lt;li&gt;INCBIN - includes External Binary Files&lt;/li&gt;
&lt;li&gt;EQU - defines constant. For example:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;;; now one is 1
one equ 1
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;TIMES - Repeating Instructions or Data. (description will be in next posts)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;arithmetic-operations:ab55faf63a1e5e0b7697868e1403e0f7&#34;&gt;Arithmetic operations&lt;/h2&gt;

&lt;p&gt;There is short list of arithmetic instructions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ADD&lt;/code&gt; - integer add&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SUB&lt;/code&gt; - substract&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MUL&lt;/code&gt; - unsigned multiply&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IMUL&lt;/code&gt; - signed multiply&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DIV&lt;/code&gt; - unsigned divide&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IDIV&lt;/code&gt; - signed divide&lt;/li&gt;
&lt;li&gt;&lt;code&gt;INC&lt;/code&gt; - increment&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DEC&lt;/code&gt; - decrement&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NEG&lt;/code&gt; - negate&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Some of it we will see at practice in this post. Other will be covered in next posts.&lt;/p&gt;

&lt;h2 id=&#34;control-flow:ab55faf63a1e5e0b7697868e1403e0f7&#34;&gt;Control flow&lt;/h2&gt;

&lt;p&gt;Usually programming languages have ability to change order of evaluation (with if statement, case statement, goto and etc&amp;hellip;) and assembly has it too. Here we will see some of it. There is cmp instruction for performing comparison between two values. It is used along with the conditional jump instruction for decision making. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;;; compare rax with 50
cmp rax, 50
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;cmp&lt;/code&gt; instruction just compares 2 values, but doesn&amp;rsquo;t affect them and doesn&amp;rsquo;t execute anything depend on result of comparison. For performing any actions after comparison there is conditional jump instructions. It can be one of it:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;JE&lt;/code&gt; - if equal&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JZ&lt;/code&gt; - if zero&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JNE&lt;/code&gt; - if not equal&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JNZ&lt;/code&gt; - if not zero&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JG&lt;/code&gt; - if first operand is greater than second&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JGE&lt;/code&gt; - if first operand is greater or equal to second&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JA&lt;/code&gt; - the same that JG, but performs unsigned comparison&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JAE&lt;/code&gt; - the same that JGE, but performs unsigned comparison&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For example if we want to make something like if/else statement in C:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;if (rax != 50) {
    exit();
} else {
    right();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will be in assembly:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;;; compare rax with 50
cmp rax, 50
;; perform .exit if rax is not equal 50
jne .exit
jmp .right
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is also unconditional jump with syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;JMP label 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;_start:
    ;; ....
    ;; do something and jump to .exit label
    ;; ....
    jmp .exit
 
.exit:
    mov    rax, 60
    mov    rdi, 0
    syscall
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we have can have some code which will be after _start label, and all of this code will be executed, assembly transfer control to .exit label, and code after .exit: will start to execute.&lt;/p&gt;

&lt;p&gt;Often unconditional jump uses in loops. For example we have label and some code after it. This code executes anything, than we have condition and jump to the start of this code if condition is not successfully. Loops will be covered in next parts.&lt;/p&gt;

&lt;h2 id=&#34;example:ab55faf63a1e5e0b7697868e1403e0f7&#34;&gt;Example&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s see simple example. It will take two integer numbers, get sum of these numbers and compare it with predefined number. If predefined number is equal to sum, it will print something on the screen, if not - just exit. Here is the source code of our example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;section .data
    ; Define constants
    num1:   equ 100
    num2:   equ 50
    ; initialize message
    msg:    db &amp;quot;Sum is correct\n&amp;quot;
 
section .text
 
    global _start
 
;; entry point
_start:
    ; set num1&#39;s value to rax
    mov rax, num1
    ; set num2&#39;s value to rbx
    mov rbx, num2
    ; get sum of rax and rbx, and store it&#39;s value in rax
    add rax, rbx
    ; compare rax and 150
    cmp rax, 150
    ; go to .exit label if rax and 150 are not equal
    jne .exit
    ; go to .rightSum label if rax and 150 are equal
    jmp .rightSum
 
; Print message that sum is correct
.rightSum:
    ;; write syscall
    mov     rax, 1
    ;; file descritor, standard output
    mov     rdi, 1
    ;; message address
    mov     rsi, msg
    ;; length of message
    mov     rdx, 15
    ;; call write syscall
    syscall
    ; exit from program
    jmp .exit
 
; exit procedure
.exit:
    ; exit syscall
    mov    rax, 60
    ; exit code
    mov    rdi, 0
    ; call exit syscall
    syscall
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s go through the source code. First of all there is data section with two constants num1, num2 and variable msg with &amp;ldquo;Sum is correct\n&amp;rdquo; value. Now look at 14 line. There is begin of program&amp;rsquo;s entry point. We transfer num1 and num2 values to general purpose registers rax and rbx. Sum it with add instruction. After execution of add instruction, it calculates sum of values from rax and rbx and store it&amp;rsquo;s value to rax. Now we have sum of num1 and num2 in the rax register.&lt;/p&gt;

&lt;p&gt;Ok we have num1 which is 100 and num2 which is 50. Our sum must be 150. Let&amp;rsquo;s check it with cmp instruction. After comparison rax and 150 we check result of comparison, if rax and 150 are not equal (checking it with jne) we go to .exit label, if they are equal we go to .rightSum label.&lt;/p&gt;

&lt;p&gt;Now we have two labels: .exit and .rightSum. First is just sets 60 to rax, it is exit system call number, and 0 to rdi, it is a exit code. Second is .rightSum is pretty easy, it just prints Sum is correct.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Say hello to x86_64 Assembly [part 1]</title>
      <link>http://localhost:1313/blog/2014/08/01/say-hello-to-x86_64-assembly-part-1/</link>
      <pubDate>Fri, 01 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/2014/08/01/say-hello-to-x86_64-assembly-part-1/</guid>
      <description>

&lt;h2 id=&#34;introduction:03653409529d0d97233d6e12221beac7&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;There are many developers between us. We write a tons of code every day. Sometime, it is even not a bad code :) Every of us can easily write the simplest code like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
 
int main() {
  int x = 10;
  int y = 100;
  printf(&amp;quot;x + y = %d&amp;quot;, x + y);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Every of us can understand what&amp;rsquo;s this C code does. But&amp;hellip; How this code works at low level? I think that not all of us can answer on this question, and me too. I thought that i can write code on high level programming languages like Haskell, Erlang, Go and etc&amp;hellip;, but i absolutely don&amp;rsquo;t know how it works at low level, after compilation. So I decided to take a few deep steps down, to assembly, and to describe my learning way about this. Hope it will be interesting, not only for me. Something about 5 - 6 years ago I already used assembly for writing simple programs, it was in university and i used Turbo assembly and DOS operating system. Now I use Linux-x86-64 operating system. Yes, must be big difference between Linux 64 bit and DOS 16 bit. So let&amp;rsquo;s start.&lt;/p&gt;

&lt;h2 id=&#34;preparation:03653409529d0d97233d6e12221beac7&#34;&gt;Preparation&lt;/h2&gt;

&lt;p&gt;Before we started, we must to prepare some things like As I wrote about, I use Ubuntu (Ubuntu 14.04.1 LTS 64 bit), thus my posts will be for this operating system and architecture. Different CPU supports different set of instructions. I use Intel Core i7 870 processor, and all code will be written processor. Also i will use nasm assembly. You can install it with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install nasm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s version must be 2.0.0 or greater. I use NASM version 2.10.09 compiled on Dec 29 2013 version. And the last part, you will need in text editor where you will write you assembly code. I use Emacs with nasm-mode.el for this. It is not mandatory, of course you can use your favourite text editor. If you use Emacs as me you can download nasm-mode.el and configure your Emacs like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(load &amp;quot;~/.emacs.d/lisp/nasm.el&amp;quot;)
(require &#39;nasm-mode)
(add-to-list &#39;auto-mode-alist &#39;(&amp;quot;\\.\\(asm\\|s\\)$&amp;quot; . nasm-mode))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s all we need for this moment. Other tools will be describe in next posts.&lt;/p&gt;

&lt;h2 id=&#34;syntax-of-nasm-assembly:03653409529d0d97233d6e12221beac7&#34;&gt;Syntax of nasm assembly&lt;/h2&gt;

&lt;p&gt;Here I will not describe full assembly syntax, we&amp;rsquo;ll mention only those parts of the syntax, which we will use in this post. Usually NASM program divided into sections. In this post we&amp;rsquo;ll meet 2 following sections:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;data section&lt;/li&gt;
&lt;li&gt;text section&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The data section is used for declaring constants. This data does not change at runtime. You can declare various math or other constants and etc&amp;hellip; The syntax for declaring data section is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;    section .data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The text section is for code. This section must begin with the declaration global _start, which tells the kernel where the program execution begins.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;    section .text
    global _start
    _start: 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Comments starts with the &lt;code&gt;;&lt;/code&gt; symbol. Every NASM source code line contains some combination of the following four fields:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[label:] instruction [operands] [; comment]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fields which are in square brackets are optional. A basic NASM instruction consists from two parts. The first one is the name of the instruction which is to be executed, and the second are the operands of this command. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;    MOV COUNT, 48 ; Put value 48 in the COUNT variable
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;hello-world:03653409529d0d97233d6e12221beac7&#34;&gt;Hello world&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s write first program with NASM assembly. And of course it will be traditional Hello world program. Here is the code of it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;section .data
    msg db      &amp;quot;hello, world!&amp;quot;
 
section .text
    global _start
_start:
    mov     rax, 1
    mov     rdi, 1
    mov     rsi, msg
    mov     rdx, 13
    syscall
    mov    rax, 60
    mov    rdi, 0
    syscall
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yes, it doesn&amp;rsquo;t look like printf(&amp;ldquo;Hello world&amp;rdquo;). Let&amp;rsquo;s try to understand what is it and how it works. Take a look 1-2 lines. We defined data section and put there msg constant with Hello world value. Now we can use this constant in our code. Next is declaration text section and entry point of program. Program will start to execute from 7 line. Now starts the most interesting part. We already know what is it mov instruction, it gets 2 operands and put value of second to first. But what is it these rax, rdi and etc&amp;hellip; As we can read in the wikipedia:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A central processing unit (CPU) is the hardware within a computer that carries out the instructions of a computer program by performing the basic arithmetical, logical, and input/output operations of the system.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok, CPU performs some operations, arithmetical and etc&amp;hellip; But where can it get data for this operations? The first answer in memory. However, reading data from and storing data into memory slows down the processor, as it involves complicated processes of sending the data request across the control bus. Thus CPU has own internal memory storage locations called registers:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i45.tinypic.com/10wtooh.png&#34; alt=&#34;registers&#34; /&gt;&lt;/p&gt;

&lt;p&gt;So when we write mov rax, 1, it means to put 1 to the rax register. Now we know what is it rax, rdi, rbx and etc&amp;hellip; But need to know when to use rax but when rsi and etc&amp;hellip;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rax&lt;/code&gt; - temporary register; when we call a syscal, rax must contain syscall number&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rdx&lt;/code&gt; - used to pass 3rd argument to functions&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rdi&lt;/code&gt; - used to pass 1st argument to functions&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rsi&lt;/code&gt; - pointer used to pass 2nd argument to functions&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In another words we just make a call of &lt;code&gt;sys_write&lt;/code&gt; syscall. Take a look on &lt;code&gt;sys_write&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;size_t sys_write(unsigned int fd, const char * buf, size_t count);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It has 3 arguments:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fd&lt;/code&gt; - file descriptor. Can be 0, 1 and 2 for standard input, standard output and standard error&lt;/li&gt;
&lt;li&gt;&lt;code&gt;buf&lt;/code&gt; - points to a character array, which can be used to store content obtained from the file pointed to by fd.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;count&lt;/code&gt; - specifies the number of bytes to be written from the file into the character array&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So we know that &lt;code&gt;sys_write&lt;/code&gt; syscall takes three arguments and has number one in syscall table. Let&amp;rsquo;s look again to our hello world implementation. We put 1 to rax register, it means that we will use sys_write system call. In next line we put 1 to rdi register, it will be first argument of &lt;code&gt;sys_write&lt;/code&gt;, 1 - standard output. Then we store pointer to msg at rsi register, it will be second buf argument for sys_write. And then we pass the last (third) parameter (length of string) to rdx, it will be third argument of sys_write. Now we have all arguments of the &lt;code&gt;sys_write&lt;/code&gt; and we can call it with syscall function at 11 line. Ok, we printed &amp;ldquo;Hello world&amp;rdquo; string, now need to do correctly exit from program. We pass 60 to rax register, 60 is a number of exit syscall. And pass also 0 to rdi register, it will be error code, so with 0 our program must exit successfully. That&amp;rsquo;s all for &amp;ldquo;Hello world&amp;rdquo;. Quite simple :) Now let&amp;rsquo;s build our program. For example we have this code in hello.asm file. Then we need to execute following commands:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ nasm -f elf64 -o hello.o hello.asm
$ ld -o hello hello.o 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After it we will have executable hello file which we can run with ./hello and will see Hello world string in the terminal.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GHCi runtime linker found a duplicate definition error</title>
      <link>http://localhost:1313/blog/2014/07/13/ghci-runtime-linker-found-a-duplicate-definition-error/</link>
      <pubDate>Sun, 13 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/2014/07/13/ghci-runtime-linker-found-a-duplicate-definition-error/</guid>
      <description>&lt;p&gt;Today I started to play with &lt;a href=&#34;https://hackage.haskell.org/package/attoparsec&#34;&gt;attoparsec&lt;/a&gt; package and tried to write simple parser. I wrote really toy data type like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;module SimpleParser where
 
import qualified Data.ByteString.Char8 as BS
import Data.Attoparsec.ByteString
 
data Str = End deriving (Show, Eq)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I tried to type:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*SimpleParser&amp;gt; End
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in ghci and will get End as I expected. Instead End I got following error:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GHCi runtime linker: fatal error: I found a duplicate definition for symbol
   _hs_bytestring_long_long_uint_hex
whilst processing object file
   /home/alex/.cabal/lib/x86_64-linux-ghc-7.6.3/bytestring-0.10.4.0/HSbytestring-0.10.4.0.o
This could be caused by:
   * Loading two different object files which export the same symbol
   * Specifying the same object file twice on the GHCi command line
   * An incorrect `package.conf&#39; entry, causing some object to be
     loaded twice.
GHCi cannot safely continue in this situation.  Exiting now.  Sorry.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we can see in error output GHCi runtime linker found duplicate definition of _hs_bytestring_long_long_uint_hex. Let&amp;rsquo;s see what&amp;rsquo;s wrong bytestring package with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cabal info bytestring
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It will give us output like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* bytestring       (library)
    Synopsis:      Fast, compact, strict and lazy byte strings with a list
                   interface
    Versions available: 0.9.0.4, 0.9.1.9, 0.9.1.10, 0.9.2.0, 0.9.2.1, 0.10.0.1,
                        0.10.0.2, 0.10.2.0, 0.10.4.0 (and 14 others)
    Versions installed: 0.10.4.0, 0.10.2.0
    Homepage:      https://github.com/haskell/bytestring
    Bug reports:   https://github.com/haskell/bytestring/issues
    Description:   An efficient compact, immutable byte string type (both strict
                   and lazy) suitable for binary or 8-bit character data.
..............................................
..............................................
..............................................
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can note that there two installed versions of bytestring package. Let&amp;rsquo;s remove old version with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo ghc-pkg unregister --force bytestring-0.10.0.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s all. After this error with GHCi runtime linker found a duplicate definition error&amp;hellip;&amp;hellip; will disappear. Hope this blog post will be useful for all who will meet error like this.&lt;/p&gt;

&lt;p&gt;Happy coding!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Using Elixir to write Ybot plugins</title>
      <link>http://localhost:1313/blog/2014/06/01/using-elixir-to-write-ybot-plugins/</link>
      <pubDate>Sun, 01 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/2014/06/01/using-elixir-to-write-ybot-plugins/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/OtpChatBot/Ybot&#34;&gt;Ybot&lt;/a&gt; - is a customizable bot which was inspired by GitHub&amp;rsquo;s Hubot and written with Erlang programming language. You can create pligin for Ybot in one of following languages:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Python&lt;/li&gt;
&lt;li&gt;Ruby&lt;/li&gt;
&lt;li&gt;Shell&lt;/li&gt;
&lt;li&gt;Perl&lt;/li&gt;
&lt;li&gt;Erlang/OTP&lt;/li&gt;
&lt;li&gt;Elixir&lt;/li&gt;
&lt;li&gt;Scala&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In this post i will tell you to create Ybot plugin with Elixir. For example we need to create Ybot&amp;rsquo;s plugin which will get information about commits from the Github&amp;rsquo;s repository and will send it to chat if somebody updated your repository. We will use Github API v3. For getting info about Github repository commits we must send request:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GET /repos/:owner/:repo/commits
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s create Elixir module and send request to the Github API:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;defmodule GithubCommitsNotification do
    
    @moduledoc &amp;quot;&amp;quot;&amp;quot;
        Github commits notification Ybot plugin.
    &amp;quot;&amp;quot;&amp;quot;
 
    @repo &#39;YBOT&#39;
    @author &#39;0xAX&#39;
    @github_api_url  &#39;https://api.github.com/repos/&#39; ++ @author ++ &#39;/&#39; ++ @repo ++ &#39;/commits&#39;
 
    @ybot_api_url &#39;http://localhost:8090/memories/&#39;
    @ybot_plugin_api_url &#39;http://localhost:8090/memories/?plugin=elixir_github_commits_notification&#39;
 
    :ok = :application.start :inets
    :ok = :application.start :asn1
    :ok = :application.start :crypto
    :ok = :application.start :public_key
    :ok = :application.start :ssl
 
    # Send request to the Github API
    {:ok, {_, _, body}} = :httpc.request(:get, {@github_api_url, []}, [{:ssl,[{:verify,0}]}], [])
    # parse response
    [resp | _] = JSON.parse(body)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here you can see simple Elixir module with some attributes (@repo, @author and etc&amp;hellip;), and sending http &amp;lsquo;GET&amp;rsquo; request to the Github commits API. We must get response like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;[
  {
    &amp;quot;url&amp;quot;: &amp;quot;https://api.github.com/repos/octocat/Hello-World/commits/6dcb09b5b57875f334f61aebed695e2e4193db5e&amp;quot;,
    &amp;quot;sha&amp;quot;: &amp;quot;6dcb09b5b57875f334f61aebed695e2e4193db5e&amp;quot;,
    &amp;quot;commit&amp;quot;: {
      &amp;quot;url&amp;quot;: &amp;quot;https://api.github.com/repos/octocat/Hello-World/git/commits/6dcb09b5b57875f334f61aebed695e2e4193db5e&amp;quot;,
      &amp;quot;author&amp;quot;: {
        &amp;quot;name&amp;quot;: &amp;quot;Monalisa Octocat&amp;quot;,
        &amp;quot;email&amp;quot;: &amp;quot;support@github.com&amp;quot;,
        &amp;quot;date&amp;quot;: &amp;quot;2011-04-14T16:00:49Z&amp;quot;
      },
      &amp;quot;committer&amp;quot;: {
        &amp;quot;name&amp;quot;: &amp;quot;Monalisa Octocat&amp;quot;,
        &amp;quot;email&amp;quot;: &amp;quot;support@github.com&amp;quot;,
        &amp;quot;date&amp;quot;: &amp;quot;2011-04-14T16:00:49Z&amp;quot;
      },
      &amp;quot;message&amp;quot;: &amp;quot;Fix all the bugs&amp;quot;,
      &amp;quot;tree&amp;quot;: {
        &amp;quot;url&amp;quot;: &amp;quot;https://api.github.com/repos/octocat/Hello-World/tree/6dcb09b5b57875f334f61aebed695e2e4193db5e&amp;quot;,
        &amp;quot;sha&amp;quot;: &amp;quot;6dcb09b5b57875f334f61aebed695e2e4193db5e&amp;quot;
      }
    },
    &amp;quot;author&amp;quot;: {
      &amp;quot;login&amp;quot;: &amp;quot;octocat&amp;quot;,
      &amp;quot;id&amp;quot;: 1,
      &amp;quot;avatar_url&amp;quot;: &amp;quot;https://github.com/images/error/octocat_happy.gif&amp;quot;,
      &amp;quot;gravatar_id&amp;quot;: &amp;quot;somehexcode&amp;quot;,
      &amp;quot;url&amp;quot;: &amp;quot;https://api.github.com/users/octocat&amp;quot;
    },
    &amp;quot;committer&amp;quot;: {
      &amp;quot;login&amp;quot;: &amp;quot;octocat&amp;quot;,
      &amp;quot;id&amp;quot;: 1,
      &amp;quot;avatar_url&amp;quot;: &amp;quot;https://github.com/images/error/octocat_happy.gif&amp;quot;,
      &amp;quot;gravatar_id&amp;quot;: &amp;quot;somehexcode&amp;quot;,
      &amp;quot;url&amp;quot;: &amp;quot;https://api.github.com/users/octocat&amp;quot;
    },
    &amp;quot;parents&amp;quot;: [
      {
        &amp;quot;url&amp;quot;: &amp;quot;https://api.github.com/repos/octocat/Hello-World/commits/6dcb09b5b57875f334f61aebed695e2e4193db5e&amp;quot;,
        &amp;quot;sha&amp;quot;: &amp;quot;6dcb09b5b57875f334f61aebed695e2e4193db5e&amp;quot;
      }
    ]
  }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we must get some fields from this response, like a commit&amp;rsquo;s author, commit message and etc&amp;hellip;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;# get sha
{&amp;lt;&amp;lt;&amp;quot;sha&amp;quot;&amp;gt;&amp;gt;, sha} = :lists.keyfind(&amp;lt;&amp;lt;&amp;quot;sha&amp;quot;&amp;gt;&amp;gt;, 1, resp)
 
# get author
{_, commit} = :lists.keyfind(&amp;lt;&amp;lt;&amp;quot;commit&amp;quot;&amp;gt;&amp;gt;, 1, resp)
{_, author} = :lists.keyfind(&amp;lt;&amp;lt;&amp;quot;author&amp;quot;&amp;gt;&amp;gt;, 1, commit)
{_, name} = :lists.keyfind(&amp;lt;&amp;lt;&amp;quot;name&amp;quot;&amp;gt;&amp;gt;, 1, author)
 
# get commit message
{&amp;lt;&amp;lt;&amp;quot;message&amp;quot;&amp;gt;&amp;gt;, message} = :lists.keyfind(&amp;lt;&amp;lt;&amp;quot;message&amp;quot;&amp;gt;&amp;gt;, 1, commit)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ybot has an own storage with REST API, thank you to &lt;a href=&#34;https://twitter.com/tajgur&#34;&gt;@tajgur&lt;/a&gt;. You can find documentation for it - here. And also Ybot has notifications support, in other words you can set up Ybot that it will execute your plugin by timeout and send result to you. For example you can configure Ybot that it will send to you status of your system every hour and etc&amp;hellip; We have memory API in Ybot and we can get last information about repository commits, check it, save last commit if it changed and will send update to the chat. Remeber that Ybot&amp;rsquo;s plugin must write it&amp;rsquo;s result to the &lt;code&gt;STDOUT&lt;/code&gt; in the end of execution. Here is the full source code of this plugin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;defmodule GithubCommitsNotification do
    
    @moduledoc &amp;quot;&amp;quot;&amp;quot;
        Github commits notification Ybot plugin.
    &amp;quot;&amp;quot;&amp;quot;
 
    @repo &#39;YBOT&#39;
    @author &#39;0xAX&#39;
    @github_api_url  &#39;https://api.github.com/repos/&#39; ++ @author ++ &#39;/&#39; ++ @repo ++ &#39;/commits&#39;
 
    @ybot_api_url &#39;http://localhost:8090/memories/&#39;
    @ybot_plugin_api_url &#39;http://localhost:8090/memories/?plugin=elixir_github_commits_notification&#39;
 
    :ok = :application.start :inets
    :ok = :application.start :asn1
    :ok = :application.start :crypto
    :ok = :application.start :public_key
    :ok = :application.start :ssl
 
    # Send request to the Github API
    {:ok, {_, _, body}} = :httpc.request(:get, {@github_api_url, []}, [{:ssl,[{:verify,0}]}], [])
    # parse response
    [resp | _] = JSON.parse(body)
 
    # get sha
    {&amp;lt;&amp;lt;&amp;quot;sha&amp;quot;&amp;gt;&amp;gt;, sha} = :lists.keyfind(&amp;lt;&amp;lt;&amp;quot;sha&amp;quot;&amp;gt;&amp;gt;, 1, resp)
 
    # get author
    {_, commit} = :lists.keyfind(&amp;lt;&amp;lt;&amp;quot;commit&amp;quot;&amp;gt;&amp;gt;, 1, resp)
    {_, author} = :lists.keyfind(&amp;lt;&amp;lt;&amp;quot;author&amp;quot;&amp;gt;&amp;gt;, 1, commit)
    {_, name} = :lists.keyfind(&amp;lt;&amp;lt;&amp;quot;name&amp;quot;&amp;gt;&amp;gt;, 1, author)
 
    # get commit message
    {&amp;lt;&amp;lt;&amp;quot;message&amp;quot;&amp;gt;&amp;gt;, message} = :lists.keyfind(&amp;lt;&amp;lt;&amp;quot;message&amp;quot;&amp;gt;&amp;gt;, 1, commit)
 
    result = &#39;New commit to the repo - &#39; ++ @repo ++  &#39; sha: &#39; ++ :erlang.binary_to_list(sha) ++ &#39; author: &#39; ++ :erlang.binary_to_list(name) 
             ++ &#39; message: &#39; ++ :erlang.binary_to_list(message)
 
    {:ok, {_, _, body}} = :httpc.request(:get, {@ybot_plugin_api_url, []}, [], [])
 
    case body do
        &#39;[]&#39; -&amp;gt;
            data = JSON.generate([plugin: &amp;quot;elixir_github_commits_notification&amp;quot;, 
                                  key: &amp;quot;sha&amp;quot;,
                                  value: sha])
 
            # save new record to Ybot storage
            :httpc.request(:post, {@ybot_api_url, [], &#39;application/json&#39;, data}, [], [])
            # write result to stdout
            :io.format(&amp;quot;~p~n&amp;quot;, [result])
        _ -&amp;gt;
            {_, val} = :lists.keyfind(&amp;lt;&amp;lt;&amp;quot;value&amp;quot;&amp;gt;&amp;gt;, 1, :lists.nth(1, JSON.parse(body)))
            {_, id}  = :lists.keyfind(&amp;lt;&amp;lt;&amp;quot;id&amp;quot;&amp;gt;&amp;gt;, 1, :lists.nth(1, JSON.parse(body)))
            
            cond do
                val == val -&amp;gt;
                    :io.format &amp;quot;&amp;quot;
                true -&amp;gt;
                    # delete old commit
                    :httpc.request(:delete, {@ybot_api_url ++ binary_to_list(id), []}, [], [])
                    
                    data = JSON.generate([plugin: &amp;quot;elixir_github_commits_notification&amp;quot;, 
                                          key: &amp;quot;sha&amp;quot;,
                                          value: sha])
 
                    # save new record to Ybot storage
                    :httpc.request(:post, {@ybot_api_url, [], &#39;application/json&#39;, data}, [], [])
                    # write result to stdout
                    :io.format(&amp;quot;~p~n&amp;quot;, [result])
            end
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Put this plugin to Ybot&amp;rsquo;s &lt;code&gt;notifications&lt;/code&gt; directory and set up it in configuration file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;{notification, [
    {github_commits_notification, [irc, twitter], 600}    
]},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;github_commits_notifications - plugin name&lt;/li&gt;
&lt;li&gt;[irc, twitter] - list of transports in which Ybot will send report&lt;/li&gt;
&lt;li&gt;600 - timeout in seconds&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can set up any transport which Ybot supports:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IRC&lt;/li&gt;
&lt;li&gt;XMPP&lt;/li&gt;
&lt;li&gt;Campfire&lt;/li&gt;
&lt;li&gt;HipChat&lt;/li&gt;
&lt;li&gt;Skype&lt;/li&gt;
&lt;li&gt;HTTP&lt;/li&gt;
&lt;li&gt;FlowDock&lt;/li&gt;
&lt;li&gt;SMTP&lt;/li&gt;
&lt;li&gt;Twitter&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>My thoughts about why Haskell is not popular</title>
      <link>http://localhost:1313/blog/2014/05/11/my-thoughts-about-why-haskell-is-not-popular/</link>
      <pubDate>Sun, 11 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/2014/05/11/my-thoughts-about-why-haskell-is-not-popular/</guid>
      <description>

&lt;p&gt;Despite Haskell programming language is not young language, it has a really great and helpful community, it has big amount of libraries, unfortunately Haskell is not popular programming language. I&amp;rsquo;m not against this programming language, opposite, haskell&amp;rsquo;s unpopularity makes me sad. I will not write about haskell popularity in industry, I&amp;rsquo;ll try to explain my thoughts about &amp;ldquo;Why Haskell is not popular&amp;rdquo; not as Haskell expert, not as professional Haskell developer (i don&amp;rsquo;t get payment for Haskell programming), but from position of usual developer who started to learn/experiment with Haskell some months ago and already don&amp;rsquo;t afraid monads :). I can&amp;rsquo;t So I will try to explain my opinion about Why Haskell is not popular in this post.&lt;/p&gt;

&lt;h2 id=&#34;myths:b6b952a1303968774d34eaa0278ec9fc&#34;&gt;Myths&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;m not long time with Haskell and I don&amp;rsquo;t know all myths/stories/jokes and other funny things about Haskell, I know one popular myth (for my look it&amp;rsquo;s a myth) that Haskell is a difficult. Difficult to learn, difficult to use, not important, it is difficult. I think it&amp;rsquo;s old myth, I remember it before I started to learn Haskell. I think that it is really myth and Haskell can be not so hard as you can think about it. It is not difficult, it is different. If you&amp;rsquo;re using python,ruby,C++,javascript,java,something else&amp;hellip; Haskell will be really different. Why it is different? There are many reasons for this like: another programming paradigm, lazy evaluations, different concepts and etc&amp;hellip; But of course it is not a big problem and relatively easy to solve. Developer just need to spend more time to learn it than with another programming languages like python,javascript and etc&amp;hellip; (Except C++ of course :))&lt;/p&gt;

&lt;h2 id=&#34;lack-of-documentation:b6b952a1303968774d34eaa0278ec9fc&#34;&gt;Lack of documentation&lt;/h2&gt;

&lt;p&gt;The Lack of documentation is a first problem in this list that related with practical side of Haskell usage. I don&amp;rsquo;t mean that Haskell as language has bad documentation, it is not true. I&amp;rsquo;m speaking about Haskell libraries documentation. It&amp;rsquo;s the one of big problem that stands on the road to Haskell popularity. Sooner or later after start of Haskell learning developer will want to use libraries written in Haskell. We can easily find library by name, or functions/data types name with Hoogle, it is good, but how to use this libraries if developer doesn&amp;rsquo;t program in Haskell a couple years and library has no or has but bad documentation. For example some time ago I played with WAI and i was need in websockets. Fortunately WAI has &lt;a href=&#34;http://hackage.haskell.org/package/wai-websockets-3.0.0&#34;&gt;wai-websockets&lt;/a&gt; package but let&amp;rsquo;s look on it&amp;rsquo;s &lt;a href=&#34;http://hackage.haskell.org/package/wai-websockets-3.0.0/docs/Network-Wai-Handler-WebSockets.html&#34;&gt;documentation&lt;/a&gt;. How to use it? I don&amp;rsquo;t know how about you, but I don&amp;rsquo;t understand. I see only one way out of this: to read &lt;a href=&#34;https://github.com/yesodweb/wai/blob/master/wai-websockets/server.lhs&#34;&gt;wai-websockets&lt;/a&gt; source code or examples. Is it good? I&amp;rsquo;m not sure.&lt;/p&gt;

&lt;h2 id=&#34;standard-library:b6b952a1303968774d34eaa0278ec9fc&#34;&gt;Standard Library&lt;/h2&gt;

&lt;p&gt;Now let&amp;rsquo;s talk about Haskell&amp;rsquo;s standard library. On my look it has many really useful things for haskell and has really little amount things for Real World play. What it means when I am telling about Real World. It&amp;rsquo;s simple, i mean that Haskell standard library has many things like Control.Category, Control.Arrow, Data.Typeable and etc&amp;hellip; Again, I don&amp;rsquo;t know how is it for you, but for me and I think other newbie Haskell developers: Category, Arrow and other magic words are just words without any meaning. Not, i know Arrows, Monads are very useful in Haskell, but where is the something like Network.TcpClient, Network.HttpServer and etc&amp;hellip; I know that Haskell has separate libraries for TCP, HTTP and other network and not only network things. But imagine, for exmaple I just started with Haskell and I want to write simple example like sending HTTP request and getting response, i need to understand where to find library for this, how to install it and etc&amp;hellip; I don&amp;rsquo;t speak that Haskell standard library must have all things for all case, but things like http client in stdlib is a standard case. Or i&amp;rsquo;m wrong? Let&amp;rsquo;s look on golang for example. I think that it has a perfect standard library. Look on it and haskell standard library, do you feel difference? Golang is only five years and Haskell is 24, so big difference. Of course I have no statistic, but I see that golang is much popular for this moment. I don&amp;rsquo;t think that it is main reason but one of.&lt;/p&gt;

&lt;h2 id=&#34;why-to-learn:b6b952a1303968774d34eaa0278ec9fc&#34;&gt;Why to learn&lt;/h2&gt;

&lt;p&gt;I think it&amp;rsquo;s not only Haskell problem, but other languages too. I see only one answer for this question: To get/improve knowledges in functional programming and look on your working programming language with other eyes after it. Yes, getting new knowledges it is very good. But what about practical side? I know that somewhere developers who get money for Haskell programming, but I don&amp;rsquo;t see tons of vacancies for Haskell developers like for javascript, ruby or other tools and it is problem. Let&amp;rsquo;s look in another side. For example i want to start learn Haskell for my super-cool pet project. But why Haskell in this case? For web development I can take habitual ruby/python/php, for system programming I can take C/C++ or maybe Rust, for concurrent programming I will choose erlang. So why i need to learn new programming language and in addition so different from my standard tools?&lt;/p&gt;

&lt;h2 id=&#34;lazyness:b6b952a1303968774d34eaa0278ec9fc&#34;&gt;Lazyness&lt;/h2&gt;

&lt;p&gt;When we start to learn Haskell we can read something like this: Haskell - general purpose programming language with non-strict evaluation. I think that many developers know about lazy evaluations, but I am really not sure that all of they knows how it works, how to correctly use it and etc&amp;hellip; In this way, I as beginner in Haskell must learn not only another programming paradigm, but also another evaluation order. It is much harder, because it is much implicit. For example let&amp;rsquo;s take a look at popular ByteString library. It provides two implementations lazy strings and strict. But I still don&amp;rsquo;t know where to use first and where to use second.&lt;/p&gt;

&lt;h2 id=&#34;different-abstractions:b6b952a1303968774d34eaa0278ec9fc&#34;&gt;Different abstractions&lt;/h2&gt;

&lt;p&gt;It is problem of Haskell learning. Haskell uses different abstractions than other programming languages. And if you know python for example it will be much easy to learn ruby than Haskell. Let&amp;rsquo;s look on simple echo example. You need to read input from stdin and prtin this string again. How we do it with python language:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;import sys
data = sys.stdin.readlines()
print data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All is transparent enough. We do this task with all imperative programming languages in this way. First we reading from stdin and put result to a variable and than pass this variable to the printing function. Let&amp;rsquo;s look at the same Haskell example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;main = do
  getLine &amp;gt;&amp;gt;= putStrLn
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok. Developer can guess about getLine and putStrLn, but what is it &amp;gt;&amp;gt;=. If we open documentation we will read something like this: &amp;gt;&amp;gt;= combine two monadic values&amp;hellip; &amp;ldquo;combine two monadic values&amp;hellip;&amp;rdquo;. What is it Monad, How to use Monad and many many different questions with not easy answers sometimes. And it is only monads (concept which standard developer could not hear never), but there are many different concepts like Functors, Comonads and many many others which you can&amp;rsquo;t meet in standard programming languages.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:b6b952a1303968774d34eaa0278ec9fc&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;So it was a short list of my thoughts why Haskell is not popular. I am very interesting what do you think about Haskell popularity.
In the end I want to remind that all from this post only my opinion and if you&amp;rsquo;re agree or disagree with me write me a comment.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Started to dive into elixir-lang</title>
      <link>http://localhost:1313/blog/2014/05/10/started-to-dive-into-elixir-lang/</link>
      <pubDate>Sat, 10 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/2014/05/10/started-to-dive-into-elixir-lang/</guid>
      <description>&lt;p&gt;Some times ago i decided to start new hobby project and in front of me had the task which instrument to choose for this task implementation. From the header you can guess that i decided to use Elixir. Why Elixir? The main reason is simple: I like Erlang and all it&amp;rsquo;s infrastructure, but in the same time i want to try something new and i think Elixir the best candidate for it. Now more details why i choose Elixir.&lt;/p&gt;

&lt;p&gt;First of all quote from Elixir site:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Elixir is a functional, meta-programming aware language built on top of the Erlang VM. It is a dynamic language with flexible syntax and macro support that leverages Erlang&#39;s abilities to build concurrent, distributed and fault-tolerant applications with hot code upgrades.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yes, meta-programming built on top of Erlang VM, very good start, what we have at the current moment.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Familiar to us patter matching:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; a = 5
5
iex(2)&amp;gt; 5 = a
5
iex(3)&amp;gt; list = [1,2,3]
[1, 2, 3]
iex(4)&amp;gt; [_, _, third] = list
[1, 2, 3]
iex(5)&amp;gt; third
3
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;Immutability:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;list = [1,2,3,4,5,6]
[1, 2, 3, 4, 5, 6]
iex(2)&amp;gt; list2 = [0 | list]
[0, 1, 2, 3, 4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the &lt;code&gt;list&lt;/code&gt; will never change, so it simply constructs a new list with a head of 0 and a tail of list.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Familiar and extended data types. Elixir’s built-in types are:&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;• Value types:
  – Arbitrary-sized integers
  – Floating point numbers
  – Atoms
  – Regular expressions&lt;/p&gt;

&lt;p&gt;• System types:
  – PIDs and Ports
  – References&lt;/p&gt;

&lt;p&gt;• Collection types
  – Lists
  – Tuples
  – Binaries&lt;/p&gt;

&lt;p&gt;And also: Keyword Lists, Ranges, Dictionaries, Maps and etc.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;High Order functions&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; f = :lists.map(fn elem -&amp;gt; elem * 5 end, [1,2,3,4,5])
[5, 10, 15, 20, 25]
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;The Amazing Pipes Operator&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; import Enum
nil
iex(2)&amp;gt; (1..10) |&amp;gt; map(&amp;amp;1*&amp;amp;1) |&amp;gt; filter(&amp;amp;1 &amp;lt; 40)
[1, 4, 9, 16, 25, 36]
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;Of course &lt;a href=&#34;http://www.erlang.org/doc/design_principles/users_guide.html&#34;&gt;OTP&lt;/a&gt;:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;defmodule OtpServer do
  use GenServer.Behaviour
 
  def init(current_number)
    when is_number(current_number) do
      { :ok, current_number }
    end
 
  def handle_call(:next_number, _from, current_number) do
    { :reply, current_number, current_number+1 }
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And many many more&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Elixir in action</title>
      <link>http://localhost:1313/blog/2014/04/14/elixir-in-action/</link>
      <pubDate>Mon, 14 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/2014/04/14/elixir-in-action/</guid>
      <description>

&lt;p&gt;&lt;em&gt;NOTE&lt;/em&gt; that development of the &lt;code&gt;Weber&lt;/code&gt; is finished. And if you&amp;rsquo;re interested in web development with elixirlang, take a look on &lt;a href=&#34;https://github.com/phoenixframework/phoenix&#34;&gt;phoenix&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As you can know from my previous blog posts (&lt;code&gt;Using elixir to write ybot plugins&lt;/code&gt;, &lt;code&gt;Example of usage elixir with cowboy&lt;/code&gt; and &lt;code&gt;Started to dive into elixir-lang&lt;/code&gt;) some times ago i started to learn and use Elixir language. I&amp;rsquo;m using elixir not very much time, but already have some feels about it. Practical part of usage of elixir is - &lt;a href=&#34;https://github.com/elixir-web/weber&#34;&gt;Weber&lt;/a&gt;. It is a MVC web framework for Elixir, and yesterday i released &lt;a href=&#34;https://twitter.com/0xAX/status/379319481694048257&#34;&gt;Weber-0.0.1&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this post i will try to describe my feels about Elixir.&lt;/p&gt;

&lt;h2 id=&#34;mix:5df44b8565d4251e584dfb856f87bd33&#34;&gt;Mix&lt;/h2&gt;

&lt;p&gt;First of all about mix tool. Mix is a first Elixir&amp;rsquo;s tool with which we meet in practice when started to use the elixir.&lt;/p&gt;

&lt;p&gt;Mix is a build tool that provides tasks for creating, compiling, testing (and soon deploying) Elixir projects. Mix is inspired by the Leiningen build tool for Clojure and was written by one of its contributors.&lt;/p&gt;

&lt;p&gt;We can create new Elixir project with: mix new project_name Build it with: mix compile Handle dependencies: mix deps.get &amp;amp;&amp;amp; mix deps.compile And the main mix&amp;rsquo;s feature as i think is a support of custum tasks. Mix task is just a Elixir module with mixed Mix.Task and run function. For example i&amp;rsquo;m using custom mix task in Weber for creating new project template:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;defmodule Mix.Tasks.Weber do
 
    @moduledoc &amp;quot;&amp;quot;&amp;quot;

       Create a new weber project template.

       Usage:

         mix weber /home/user/myWebApp - Creates myWebApp directory with weber project skeleton.
         mix weber --version - Prints weber version.
    &amp;quot;&amp;quot;&amp;quot;
 
    @shortdoc &amp;quot;Create a new weber project&amp;quot;
 
    use Mix.Task
    
    @version Weber.Mixfile.project[:version]
    
    def run([]) do
        usage
    end
 
    def run([&amp;quot;--help&amp;quot;]) do
        usage
    end
 
    def run([&amp;quot;--version&amp;quot;]) do
        Mix.shell.info &amp;quot;Weber v#{@version}&amp;quot;
    end
 
    def run([args]) do
      #
      # Create here new project template
      #
      .....
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;otp:5df44b8565d4251e584dfb856f87bd33&#34;&gt;OTP&lt;/h2&gt;

&lt;p&gt;As Elixir is built on top of Erlang virtual machine, we can easily to build OTP application with Elixir:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;defmodule Weber do
    use Application.Behaviour
 
    def start(_type, _args) do
        Weber.Supervisor.start_link
    end

    def stop(_state) do
        :ok
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Root supervisor:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;defmodule Weber.Supervisor do
    use Supervisor.Behaviour
 
    def start_link do
        :supervisor.start_link({:local, __MODULE__}, __MODULE__, [])
    end
 
    def start_app(app_name, routes, root_directory, config) do
        :supervisor.start_child(__MODULE__, [app_name, routes, root_directory, config])
    end
 
    def init([]) do
      children = [ worker(Weber.App, [])]
      supervise children, strategy: :simple_one_for_one
    end
 
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And simple gen_server:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;defmodule Weber.App do
    use GenServer.Behaviour
 
    defrecord WeberApp,
      name:   nil, 
      routes: nil,
      config: nil,
      root:   nil,
      static_dir: nil,
      views_dir:  nil
    
    def start_link(app_name, routes, root_directory, config) do
        :gen_server.start_link({:local, app_name}, __MODULE__, [app_name, routes, root_directory, config], [])
    end
 
    def init([app_name, routes, root_directory, config]) do
        :gen_server.cast(:erlang.self(), :init)
        { :ok, WeberApp.new name: app_name, 
                            routes: routes, 
                            root: root_directory, 
                            config: config,
                            static_dir: root_directory ++ &#39;/lib/static/&#39;,
                            views_dir:  root_directory ++ &#39;/lib/views/&#39; }
    end
 
    def handle_cast(:init, state) do
        {:noreply, state}
    end
 
    def handle_call(:routes, _from, state) do
      { :reply, state.routes, state }
    end
 
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;compile and start it with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ iex -S mix 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;testing:5df44b8565d4251e584dfb856f87bd33&#34;&gt;Testing&lt;/h2&gt;

&lt;p&gt;There is ExUnit! It is a unit test framework that ships with Elixir. Let see in routing functions from the Weber:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;def on(path, controller, action) do
        [[path: path, controller: controller, action: action]]
    end
 
    def on(routesList, path, controller, action) do
        :lists.append(routesList, [[path: path, controller: controller, action: action]])
    end
 
    @doc &amp;quot;&amp;quot;&amp;quot;
      Router attribute
    &amp;quot;&amp;quot;&amp;quot;
    def otherwise(path, controller, action) do
        on(path, controller, action)
    end
 
    def otherwise(routesList, path, controller, action) do
        on(routesList, path, controller, action)
    end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now we can write unit tests for it with ExUnit:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt; test &amp;quot;Test for Weber.Route.on and Weber.Route.otherwise&amp;quot; do
      r = on(&amp;quot;/&amp;quot;, &#39;controller1&#39;, &#39;main_action&#39;)
          |&amp;gt; on(&amp;quot;/user/0xAX/add&amp;quot;, &#39;controller1&#39;, &#39;action2&#39;)
          |&amp;gt; on(&amp;quot;/user/:user/delete&amp;quot;, &#39;controller1&#39;, &#39;action2&#39;)
          |&amp;gt; otherwise(404, &#39;controller1&#39;, &#39;notfound&#39;)
    
      assert(r == [[path: &amp;quot;/&amp;quot;, controller: &#39;controller1&#39;, action: &#39;main_action&#39;], 
                   [path: &amp;quot;/user/0xAX/add&amp;quot;, controller: &#39;controller1&#39;, action: &#39;action2&#39;], 
                   [path: &amp;quot;/user/:user/delete&amp;quot;, controller: &#39;controller1&#39;, action: &#39;action2&#39;], 
                   [path: 404, controller: &#39;controller1&#39;, action: &#39;notfound&#39;]
                  ])
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;libraries:5df44b8565d4251e584dfb856f87bd33&#34;&gt;Libraries&lt;/h2&gt;

&lt;p&gt;Although Elixir is now young language, it has good set of libraries:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/guedes/exjson&#34;&gt;exjson&lt;/a&gt; - JSON parser and genarator in Elixir;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/elixir-lang/ecto&#34;&gt;ecto&lt;/a&gt; - A database wrapper and language integrated query for Elixir;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/myfreeweb/httpotion&#34;&gt;httpotion&lt;/a&gt; - The HTTP client for Elixir;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/josephwilk/amrita&#34;&gt;amrita&lt;/a&gt; - A polite, well mannered and thoroughly upstanding testing framework for Elixir;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/meh/elixir-socket&#34;&gt;elixir-socket&lt;/a&gt; - Socket wrapping for Elixir;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yrashk/genx&#34;&gt;genx&lt;/a&gt; - Elixir-style library for most important OTP functionality;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/meh/elixir-datastructures&#34;&gt;elixir-datastructures&lt;/a&gt; - Datastructures for Elixir.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;and many more. Or you of course can use any erlang libraries. Just include it to your mix.exs file as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;...
 defp deps do
    [
      {:cowboy, &amp;quot;0.8.6&amp;quot;, github: &amp;quot;extend/cowboy&amp;quot;},
      {:ecto, github: &amp;quot;elixir-lang/ecto&amp;quot;},
      {:pgsql, github: &amp;quot;ericmj/pgsql&amp;quot;, branch: &amp;quot;elixir&amp;quot;},
      {:exjson, github: &amp;quot;guedes/exjson&amp;quot;}
    ]
  end
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and execute&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mix deps.get 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the end of this post i want to say many thanks to the Elixir community which helped me all this day, you&amp;rsquo;re great!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Implementing tcp socket acceptor pool with golang</title>
      <link>http://localhost:1313/blog/2014/04/06/implementing-tcp-socket-acceptor-pool-with-golang/</link>
      <pubDate>Sun, 06 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/2014/04/06/implementing-tcp-socket-acceptor-pool-with-golang/</guid>
      <description>&lt;p&gt;So, as maybe some of you knows that i have started to use Golang programming language for my pet projects and since to solve &amp;ldquo;Project Euler&amp;rdquo; tasks is very useful deal, but very boring in the same time, i decided to create something more closer to real life. I decided to write XMPP server in golang and in this post i will tell about one part of this server - netpool/tcp library. netpool/tcp - is a tcp based socket acceptor pool. The idea is very simple, you will launch TCP listener which will launch many acceptors besides one, in this way you no need to spend time for creating new connection acceptor.&lt;/p&gt;

&lt;p&gt;First of all let&amp;rsquo;s create new tcp package and import all libraries which will we need in this project:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package tcp
 
import &amp;quot;io&amp;quot;
import &amp;quot;log&amp;quot;
import &amp;quot;net&amp;quot;
import &amp;quot;bufio&amp;quot;
import &amp;quot;strconv&amp;quot;
import &amp;quot;crypto/tls&amp;quot;
import &amp;quot;crypto/rand&amp;quot;
import &amp;quot;net/textproto&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s define types which we will need in our acceptor pool:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;const (
    RefuseConnection = iota
    IncreaseConnection
)
 
const defaultIncreaseAcceptors = 50
 
//
// Listener instance
//
type Listener struct {
    Accnb int
    Port  int
    Handler Handler
    Lc    chan string
    OverFlowStrategy int
    Ssl   map[string]string
}
 
//
// Connection handler
//
type Handler func(string, Connection)
 
//
// Connection wrapper 
//
type Connection struct {
    Conn  net.Conn
    Write chan []byte
    Quit chan bool
    Listener *Listener
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s go by order. First enumeration defines strategies when connection listener handles more connections than we define.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RefuseConnection&lt;/code&gt; - listener will refuse connections after connections amount overflow;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IncreaseConnection&lt;/code&gt; - listener will start yet another 50 acceptors.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The next is simpe constant value which defines how many acceptors need to start after connections amount overflow. Next is &lt;code&gt;ListenerStruct&lt;/code&gt; structure. It is a main structure which we will pass to StartListener function for launching new listener. It has following fields:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Accnb&lt;/code&gt; - number of acceptors;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Port&lt;/code&gt; - connection port;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Handler&lt;/code&gt; - function with 2 parameters: input string and conn tcp.Connection. It will calls when client send something to server;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Lc&lt;/code&gt; - listener channel, it needs for communicating with listener;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OverFlowStrategy&lt;/code&gt; - It can be 0 || 1, see note about overflow strategies;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ssl&lt;/code&gt; - it is a map, we need to use it if we want to use ssl. Just create map with 2 string keys: pam and key. Next if will show how to use it.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Also it has API which consists now only from one function - StopListener without any arguments, you can stop current connection with it. Next is a Connection structure. We have it every time as second parameter in connection handler function. It has simple API for manipulating with connection:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Connection.Close&lt;/code&gt; - close current connection;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Connection.Send&lt;/code&gt;  - send response.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So, now web have all types which we will use in this library. Now proceed to implementation. All API of netpool/tcp consists only from one function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func StartNewListener(listener *Listener) {
 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s a main function of this library and it launches new tcp listener and some acceptors. Let&amp;rsquo;s see how it implemented. First of all it defines some variables like: acceptorCounter for count acceptors, checks is it connection over SSL or not and launches listener which depends on this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var err error	
var ln net.Listener
var cert tls.Certificate
 
if listener.Ssl == nil {
    ln, err = net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;:&amp;quot; + strconv.Itoa(listener.Port))
} else {
    cert, err = tls.LoadX509KeyPair(listener.Ssl[&amp;quot;pem&amp;quot;], listener.Ssl[&amp;quot;key&amp;quot;])
    config := tls.Config{Certificates: []tls.Certificate{cert}}
    config.Rand = rand.Reader
    ln, err = tls.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;:&amp;quot; + strconv.Itoa(listener.Port), &amp;amp;config)
}
	
if err != nil {
    log.Print(&amp;quot;[Error] TCP listener didn&#39;t start: &amp;quot;, err)
    return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next it creates 2 channels:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;connectionCounter&lt;/code&gt; - channel for communicating between acceptor goroutines and listener. If connection was closed it sends message to listener and listener decrease connection numbers, if new connection was accepted it increase connection number;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;closeConnection&lt;/code&gt; - channel for commuicating between listener and acceptor for closing current connection.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;and starts acceptors:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;connectionCounter := make(chan int)
closeConnection      := make(chan bool)
 
// start all acceptors
for accs := 0; accs &amp;lt; listener.Accnb; accs++ {
    go acceptor(accs, ln, connectionCounter, listener, closeConnection, acceptorsCounter) 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After this listener waits for messages from another goroutines for closing current listener, closing connection, connection removed/created and etc&amp;hellip;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for { 
    switch listener.OverFlowStrategy {
    case 0:         
        if acceptorsCounter &amp;gt;= listener.Accnb {
            conn, _ := ln.Accept()
            conn.Close()
        }
        case 1:
        listener.Accnb += 50
        for i := 0; i &amp;lt; defaultIncreaseAcceptors; i++ {
            go acceptor(i, ln, connectionCounter, listener, closeConnection, acceptorsCounter)
        }
    }
        
    select {
    case msg := &amp;lt;-connectionCounter:
        if msg == -1 {
            acceptorsCounter--
        } else {
            acceptorsCounter++
        }
    case msg := &amp;lt;-listener.Lc:
        if msg == &amp;quot;stop&amp;quot; {
            closeConnection &amp;lt;- true
            close(listener.Lc)
            close(connectionCounter)
            ln.Close()
            return
        }           
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So what about acceptors&amp;hellip; It&amp;rsquo;s pretty simple as a listener implementation, it starts from accepting new connection and waits for incoming messages from connected client. If there are any incoming data from client it call handler function and pass input data and &lt;code&gt;Connection&lt;/code&gt; structure to it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func acceptor(acc int, ln net.Listener, counterChannel chan int, listener *Listener, closeChannel chan bool, accCounter int) {  
    
    conn, err := ln.Accept()
    
    if err != nil {
        log.Print(&amp;quot;[Error] Tcp listener can&#39;t accept new connection: &amp;quot;, acc)
        return
    }
    
    // send to the listener info about new accepted connection
    counterChannel &amp;lt;- 1
    // create new connection struct
    newConnection := &amp;amp;Connection{conn, make(chan []byte), make(chan bool), listener}
    
    //
    // start to handle new connction
    //
    for {
        line, inputErr := textproto.NewReader(bufio.NewReader(conn)).ReadLine()     
        
        if inputErr == io.EOF {
            log.Print(&amp;quot;inputErr: &amp;quot;, inputErr)
            // close connection
            conn.Close()
            // tell to listener that one acceptor died
            counterChannel &amp;lt;- -1
            
            return
        }
        
        go listener.Handler(line, *newConnection)
        
        //
        // .... 
        //
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After this it as a listener checks incoming message from other goroutines, to stop connection and etc&amp;hellip;&lt;/p&gt;

&lt;p&gt;So it&amp;rsquo;s end. As we can saw concurrency is a pretty simple with Golang.&lt;/p&gt;

&lt;p&gt;As i said in previous post i&amp;rsquo;m not a golang super-hacker, if you will have any recommendations for my golang code or you want to take part in XMPP server developing with golang i will be very pleased to hear it, write me in comment or ping me in &lt;a href=&#34;https://twitter.com/0xAX&#34;&gt;twitter&lt;/a&gt;. Also i made this library primarily for future extd XMPP server but i tried to make it generic so i think it can be useful not only for me.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>