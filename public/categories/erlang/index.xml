<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Erlang on 0xAX blog</title>
    <link>http://localhost:1313/categories/erlang/</link>
    <description>Recent content in Erlang on 0xAX blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 01 Jun 2014 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/erlang/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Using Elixir to write Ybot plugins</title>
      <link>http://localhost:1313/blog/2014/06/01/using-elixir-to-write-ybot-plugins/</link>
      <pubDate>Sun, 01 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/2014/06/01/using-elixir-to-write-ybot-plugins/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/OtpChatBot/Ybot&#34;&gt;Ybot&lt;/a&gt; - is a customizable bot which was inspired by GitHub&amp;rsquo;s Hubot and written with Erlang programming language. You can create pligin for Ybot in one of following languages:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Python&lt;/li&gt;
&lt;li&gt;Ruby&lt;/li&gt;
&lt;li&gt;Shell&lt;/li&gt;
&lt;li&gt;Perl&lt;/li&gt;
&lt;li&gt;Erlang/OTP&lt;/li&gt;
&lt;li&gt;Elixir&lt;/li&gt;
&lt;li&gt;Scala&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In this post i will tell you to create Ybot plugin with Elixir. For example we need to create Ybot&amp;rsquo;s plugin which will get information about commits from the Github&amp;rsquo;s repository and will send it to chat if somebody updated your repository. We will use Github API v3. For getting info about Github repository commits we must send request:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GET /repos/:owner/:repo/commits
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s create Elixir module and send request to the Github API:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;defmodule GithubCommitsNotification do
    
    @moduledoc &amp;quot;&amp;quot;&amp;quot;
        Github commits notification Ybot plugin.
    &amp;quot;&amp;quot;&amp;quot;
 
    @repo &#39;YBOT&#39;
    @author &#39;0xAX&#39;
    @github_api_url  &#39;https://api.github.com/repos/&#39; ++ @author ++ &#39;/&#39; ++ @repo ++ &#39;/commits&#39;
 
    @ybot_api_url &#39;http://localhost:8090/memories/&#39;
    @ybot_plugin_api_url &#39;http://localhost:8090/memories/?plugin=elixir_github_commits_notification&#39;
 
    :ok = :application.start :inets
    :ok = :application.start :asn1
    :ok = :application.start :crypto
    :ok = :application.start :public_key
    :ok = :application.start :ssl
 
    # Send request to the Github API
    {:ok, {_, _, body}} = :httpc.request(:get, {@github_api_url, []}, [{:ssl,[{:verify,0}]}], [])
    # parse response
    [resp | _] = JSON.parse(body)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here you can see simple Elixir module with some attributes (@repo, @author and etc&amp;hellip;), and sending http &amp;lsquo;GET&amp;rsquo; request to the Github commits API. We must get response like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;[
  {
    &amp;quot;url&amp;quot;: &amp;quot;https://api.github.com/repos/octocat/Hello-World/commits/6dcb09b5b57875f334f61aebed695e2e4193db5e&amp;quot;,
    &amp;quot;sha&amp;quot;: &amp;quot;6dcb09b5b57875f334f61aebed695e2e4193db5e&amp;quot;,
    &amp;quot;commit&amp;quot;: {
      &amp;quot;url&amp;quot;: &amp;quot;https://api.github.com/repos/octocat/Hello-World/git/commits/6dcb09b5b57875f334f61aebed695e2e4193db5e&amp;quot;,
      &amp;quot;author&amp;quot;: {
        &amp;quot;name&amp;quot;: &amp;quot;Monalisa Octocat&amp;quot;,
        &amp;quot;email&amp;quot;: &amp;quot;support@github.com&amp;quot;,
        &amp;quot;date&amp;quot;: &amp;quot;2011-04-14T16:00:49Z&amp;quot;
      },
      &amp;quot;committer&amp;quot;: {
        &amp;quot;name&amp;quot;: &amp;quot;Monalisa Octocat&amp;quot;,
        &amp;quot;email&amp;quot;: &amp;quot;support@github.com&amp;quot;,
        &amp;quot;date&amp;quot;: &amp;quot;2011-04-14T16:00:49Z&amp;quot;
      },
      &amp;quot;message&amp;quot;: &amp;quot;Fix all the bugs&amp;quot;,
      &amp;quot;tree&amp;quot;: {
        &amp;quot;url&amp;quot;: &amp;quot;https://api.github.com/repos/octocat/Hello-World/tree/6dcb09b5b57875f334f61aebed695e2e4193db5e&amp;quot;,
        &amp;quot;sha&amp;quot;: &amp;quot;6dcb09b5b57875f334f61aebed695e2e4193db5e&amp;quot;
      }
    },
    &amp;quot;author&amp;quot;: {
      &amp;quot;login&amp;quot;: &amp;quot;octocat&amp;quot;,
      &amp;quot;id&amp;quot;: 1,
      &amp;quot;avatar_url&amp;quot;: &amp;quot;https://github.com/images/error/octocat_happy.gif&amp;quot;,
      &amp;quot;gravatar_id&amp;quot;: &amp;quot;somehexcode&amp;quot;,
      &amp;quot;url&amp;quot;: &amp;quot;https://api.github.com/users/octocat&amp;quot;
    },
    &amp;quot;committer&amp;quot;: {
      &amp;quot;login&amp;quot;: &amp;quot;octocat&amp;quot;,
      &amp;quot;id&amp;quot;: 1,
      &amp;quot;avatar_url&amp;quot;: &amp;quot;https://github.com/images/error/octocat_happy.gif&amp;quot;,
      &amp;quot;gravatar_id&amp;quot;: &amp;quot;somehexcode&amp;quot;,
      &amp;quot;url&amp;quot;: &amp;quot;https://api.github.com/users/octocat&amp;quot;
    },
    &amp;quot;parents&amp;quot;: [
      {
        &amp;quot;url&amp;quot;: &amp;quot;https://api.github.com/repos/octocat/Hello-World/commits/6dcb09b5b57875f334f61aebed695e2e4193db5e&amp;quot;,
        &amp;quot;sha&amp;quot;: &amp;quot;6dcb09b5b57875f334f61aebed695e2e4193db5e&amp;quot;
      }
    ]
  }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we must get some fields from this response, like a commit&amp;rsquo;s author, commit message and etc&amp;hellip;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;# get sha
{&amp;lt;&amp;lt;&amp;quot;sha&amp;quot;&amp;gt;&amp;gt;, sha} = :lists.keyfind(&amp;lt;&amp;lt;&amp;quot;sha&amp;quot;&amp;gt;&amp;gt;, 1, resp)
 
# get author
{_, commit} = :lists.keyfind(&amp;lt;&amp;lt;&amp;quot;commit&amp;quot;&amp;gt;&amp;gt;, 1, resp)
{_, author} = :lists.keyfind(&amp;lt;&amp;lt;&amp;quot;author&amp;quot;&amp;gt;&amp;gt;, 1, commit)
{_, name} = :lists.keyfind(&amp;lt;&amp;lt;&amp;quot;name&amp;quot;&amp;gt;&amp;gt;, 1, author)
 
# get commit message
{&amp;lt;&amp;lt;&amp;quot;message&amp;quot;&amp;gt;&amp;gt;, message} = :lists.keyfind(&amp;lt;&amp;lt;&amp;quot;message&amp;quot;&amp;gt;&amp;gt;, 1, commit)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ybot has an own storage with REST API, thank you to &lt;a href=&#34;https://twitter.com/tajgur&#34;&gt;@tajgur&lt;/a&gt;. You can find documentation for it - here. And also Ybot has notifications support, in other words you can set up Ybot that it will execute your plugin by timeout and send result to you. For example you can configure Ybot that it will send to you status of your system every hour and etc&amp;hellip; We have memory API in Ybot and we can get last information about repository commits, check it, save last commit if it changed and will send update to the chat. Remeber that Ybot&amp;rsquo;s plugin must write it&amp;rsquo;s result to the &lt;code&gt;STDOUT&lt;/code&gt; in the end of execution. Here is the full source code of this plugin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;defmodule GithubCommitsNotification do
    
    @moduledoc &amp;quot;&amp;quot;&amp;quot;
        Github commits notification Ybot plugin.
    &amp;quot;&amp;quot;&amp;quot;
 
    @repo &#39;YBOT&#39;
    @author &#39;0xAX&#39;
    @github_api_url  &#39;https://api.github.com/repos/&#39; ++ @author ++ &#39;/&#39; ++ @repo ++ &#39;/commits&#39;
 
    @ybot_api_url &#39;http://localhost:8090/memories/&#39;
    @ybot_plugin_api_url &#39;http://localhost:8090/memories/?plugin=elixir_github_commits_notification&#39;
 
    :ok = :application.start :inets
    :ok = :application.start :asn1
    :ok = :application.start :crypto
    :ok = :application.start :public_key
    :ok = :application.start :ssl
 
    # Send request to the Github API
    {:ok, {_, _, body}} = :httpc.request(:get, {@github_api_url, []}, [{:ssl,[{:verify,0}]}], [])
    # parse response
    [resp | _] = JSON.parse(body)
 
    # get sha
    {&amp;lt;&amp;lt;&amp;quot;sha&amp;quot;&amp;gt;&amp;gt;, sha} = :lists.keyfind(&amp;lt;&amp;lt;&amp;quot;sha&amp;quot;&amp;gt;&amp;gt;, 1, resp)
 
    # get author
    {_, commit} = :lists.keyfind(&amp;lt;&amp;lt;&amp;quot;commit&amp;quot;&amp;gt;&amp;gt;, 1, resp)
    {_, author} = :lists.keyfind(&amp;lt;&amp;lt;&amp;quot;author&amp;quot;&amp;gt;&amp;gt;, 1, commit)
    {_, name} = :lists.keyfind(&amp;lt;&amp;lt;&amp;quot;name&amp;quot;&amp;gt;&amp;gt;, 1, author)
 
    # get commit message
    {&amp;lt;&amp;lt;&amp;quot;message&amp;quot;&amp;gt;&amp;gt;, message} = :lists.keyfind(&amp;lt;&amp;lt;&amp;quot;message&amp;quot;&amp;gt;&amp;gt;, 1, commit)
 
    result = &#39;New commit to the repo - &#39; ++ @repo ++  &#39; sha: &#39; ++ :erlang.binary_to_list(sha) ++ &#39; author: &#39; ++ :erlang.binary_to_list(name) 
             ++ &#39; message: &#39; ++ :erlang.binary_to_list(message)
 
    {:ok, {_, _, body}} = :httpc.request(:get, {@ybot_plugin_api_url, []}, [], [])
 
    case body do
        &#39;[]&#39; -&amp;gt;
            data = JSON.generate([plugin: &amp;quot;elixir_github_commits_notification&amp;quot;, 
                                  key: &amp;quot;sha&amp;quot;,
                                  value: sha])
 
            # save new record to Ybot storage
            :httpc.request(:post, {@ybot_api_url, [], &#39;application/json&#39;, data}, [], [])
            # write result to stdout
            :io.format(&amp;quot;~p~n&amp;quot;, [result])
        _ -&amp;gt;
            {_, val} = :lists.keyfind(&amp;lt;&amp;lt;&amp;quot;value&amp;quot;&amp;gt;&amp;gt;, 1, :lists.nth(1, JSON.parse(body)))
            {_, id}  = :lists.keyfind(&amp;lt;&amp;lt;&amp;quot;id&amp;quot;&amp;gt;&amp;gt;, 1, :lists.nth(1, JSON.parse(body)))
            
            cond do
                val == val -&amp;gt;
                    :io.format &amp;quot;&amp;quot;
                true -&amp;gt;
                    # delete old commit
                    :httpc.request(:delete, {@ybot_api_url ++ binary_to_list(id), []}, [], [])
                    
                    data = JSON.generate([plugin: &amp;quot;elixir_github_commits_notification&amp;quot;, 
                                          key: &amp;quot;sha&amp;quot;,
                                          value: sha])
 
                    # save new record to Ybot storage
                    :httpc.request(:post, {@ybot_api_url, [], &#39;application/json&#39;, data}, [], [])
                    # write result to stdout
                    :io.format(&amp;quot;~p~n&amp;quot;, [result])
            end
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Put this plugin to Ybot&amp;rsquo;s &lt;code&gt;notifications&lt;/code&gt; directory and set up it in configuration file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;{notification, [
    {github_commits_notification, [irc, twitter], 600}    
]},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;github_commits_notifications - plugin name&lt;/li&gt;
&lt;li&gt;[irc, twitter] - list of transports in which Ybot will send report&lt;/li&gt;
&lt;li&gt;600 - timeout in seconds&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can set up any transport which Ybot supports:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IRC&lt;/li&gt;
&lt;li&gt;XMPP&lt;/li&gt;
&lt;li&gt;Campfire&lt;/li&gt;
&lt;li&gt;HipChat&lt;/li&gt;
&lt;li&gt;Skype&lt;/li&gt;
&lt;li&gt;HTTP&lt;/li&gt;
&lt;li&gt;FlowDock&lt;/li&gt;
&lt;li&gt;SMTP&lt;/li&gt;
&lt;li&gt;Twitter&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Started to dive into elixir-lang</title>
      <link>http://localhost:1313/blog/2014/05/10/started-to-dive-into-elixir-lang/</link>
      <pubDate>Sat, 10 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/2014/05/10/started-to-dive-into-elixir-lang/</guid>
      <description>&lt;p&gt;Some times ago i decided to start new hobby project and in front of me had the task which instrument to choose for this task implementation. From the header you can guess that i decided to use Elixir. Why Elixir? The main reason is simple: I like Erlang and all it&amp;rsquo;s infrastructure, but in the same time i want to try something new and i think Elixir the best candidate for it. Now more details why i choose Elixir.&lt;/p&gt;

&lt;p&gt;First of all quote from Elixir site:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Elixir is a functional, meta-programming aware language built on top of the Erlang VM. It is a dynamic language with flexible syntax and macro support that leverages Erlang&#39;s abilities to build concurrent, distributed and fault-tolerant applications with hot code upgrades.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yes, meta-programming built on top of Erlang VM, very good start, what we have at the current moment.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Familiar to us patter matching:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; a = 5
5
iex(2)&amp;gt; 5 = a
5
iex(3)&amp;gt; list = [1,2,3]
[1, 2, 3]
iex(4)&amp;gt; [_, _, third] = list
[1, 2, 3]
iex(5)&amp;gt; third
3
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;Immutability:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;list = [1,2,3,4,5,6]
[1, 2, 3, 4, 5, 6]
iex(2)&amp;gt; list2 = [0 | list]
[0, 1, 2, 3, 4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the &lt;code&gt;list&lt;/code&gt; will never change, so it simply constructs a new list with a head of 0 and a tail of list.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Familiar and extended data types. Elixir’s built-in types are:&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;• Value types:
  – Arbitrary-sized integers
  – Floating point numbers
  – Atoms
  – Regular expressions&lt;/p&gt;

&lt;p&gt;• System types:
  – PIDs and Ports
  – References&lt;/p&gt;

&lt;p&gt;• Collection types
  – Lists
  – Tuples
  – Binaries&lt;/p&gt;

&lt;p&gt;And also: Keyword Lists, Ranges, Dictionaries, Maps and etc.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;High Order functions&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; f = :lists.map(fn elem -&amp;gt; elem * 5 end, [1,2,3,4,5])
[5, 10, 15, 20, 25]
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;The Amazing Pipes Operator&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; import Enum
nil
iex(2)&amp;gt; (1..10) |&amp;gt; map(&amp;amp;1*&amp;amp;1) |&amp;gt; filter(&amp;amp;1 &amp;lt; 40)
[1, 4, 9, 16, 25, 36]
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;Of course &lt;a href=&#34;http://www.erlang.org/doc/design_principles/users_guide.html&#34;&gt;OTP&lt;/a&gt;:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;defmodule OtpServer do
  use GenServer.Behaviour
 
  def init(current_number)
    when is_number(current_number) do
      { :ok, current_number }
    end
 
  def handle_call(:next_number, _from, current_number) do
    { :reply, current_number, current_number+1 }
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And many many more&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Elixir in action</title>
      <link>http://localhost:1313/blog/2014/04/14/elixir-in-action/</link>
      <pubDate>Mon, 14 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/2014/04/14/elixir-in-action/</guid>
      <description>

&lt;p&gt;&lt;em&gt;NOTE&lt;/em&gt; that development of the &lt;code&gt;Weber&lt;/code&gt; is finished. And if you&amp;rsquo;re interested in web development with elixirlang, take a look on &lt;a href=&#34;https://github.com/phoenixframework/phoenix&#34;&gt;phoenix&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As you can know from my previous blog posts (&lt;code&gt;Using elixir to write ybot plugins&lt;/code&gt;, &lt;code&gt;Example of usage elixir with cowboy&lt;/code&gt; and &lt;code&gt;Started to dive into elixir-lang&lt;/code&gt;) some times ago i started to learn and use Elixir language. I&amp;rsquo;m using elixir not very much time, but already have some feels about it. Practical part of usage of elixir is - &lt;a href=&#34;https://github.com/elixir-web/weber&#34;&gt;Weber&lt;/a&gt;. It is a MVC web framework for Elixir, and yesterday i released &lt;a href=&#34;https://twitter.com/0xAX/status/379319481694048257&#34;&gt;Weber-0.0.1&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this post i will try to describe my feels about Elixir.&lt;/p&gt;

&lt;h2 id=&#34;mix:5df44b8565d4251e584dfb856f87bd33&#34;&gt;Mix&lt;/h2&gt;

&lt;p&gt;First of all about mix tool. Mix is a first Elixir&amp;rsquo;s tool with which we meet in practice when started to use the elixir.&lt;/p&gt;

&lt;p&gt;Mix is a build tool that provides tasks for creating, compiling, testing (and soon deploying) Elixir projects. Mix is inspired by the Leiningen build tool for Clojure and was written by one of its contributors.&lt;/p&gt;

&lt;p&gt;We can create new Elixir project with: mix new project_name Build it with: mix compile Handle dependencies: mix deps.get &amp;amp;&amp;amp; mix deps.compile And the main mix&amp;rsquo;s feature as i think is a support of custum tasks. Mix task is just a Elixir module with mixed Mix.Task and run function. For example i&amp;rsquo;m using custom mix task in Weber for creating new project template:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;defmodule Mix.Tasks.Weber do
 
    @moduledoc &amp;quot;&amp;quot;&amp;quot;

       Create a new weber project template.

       Usage:

         mix weber /home/user/myWebApp - Creates myWebApp directory with weber project skeleton.
         mix weber --version - Prints weber version.
    &amp;quot;&amp;quot;&amp;quot;
 
    @shortdoc &amp;quot;Create a new weber project&amp;quot;
 
    use Mix.Task
    
    @version Weber.Mixfile.project[:version]
    
    def run([]) do
        usage
    end
 
    def run([&amp;quot;--help&amp;quot;]) do
        usage
    end
 
    def run([&amp;quot;--version&amp;quot;]) do
        Mix.shell.info &amp;quot;Weber v#{@version}&amp;quot;
    end
 
    def run([args]) do
      #
      # Create here new project template
      #
      .....
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;otp:5df44b8565d4251e584dfb856f87bd33&#34;&gt;OTP&lt;/h2&gt;

&lt;p&gt;As Elixir is built on top of Erlang virtual machine, we can easily to build OTP application with Elixir:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;defmodule Weber do
    use Application.Behaviour
 
    def start(_type, _args) do
        Weber.Supervisor.start_link
    end

    def stop(_state) do
        :ok
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Root supervisor:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;defmodule Weber.Supervisor do
    use Supervisor.Behaviour
 
    def start_link do
        :supervisor.start_link({:local, __MODULE__}, __MODULE__, [])
    end
 
    def start_app(app_name, routes, root_directory, config) do
        :supervisor.start_child(__MODULE__, [app_name, routes, root_directory, config])
    end
 
    def init([]) do
      children = [ worker(Weber.App, [])]
      supervise children, strategy: :simple_one_for_one
    end
 
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And simple gen_server:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;defmodule Weber.App do
    use GenServer.Behaviour
 
    defrecord WeberApp,
      name:   nil, 
      routes: nil,
      config: nil,
      root:   nil,
      static_dir: nil,
      views_dir:  nil
    
    def start_link(app_name, routes, root_directory, config) do
        :gen_server.start_link({:local, app_name}, __MODULE__, [app_name, routes, root_directory, config], [])
    end
 
    def init([app_name, routes, root_directory, config]) do
        :gen_server.cast(:erlang.self(), :init)
        { :ok, WeberApp.new name: app_name, 
                            routes: routes, 
                            root: root_directory, 
                            config: config,
                            static_dir: root_directory ++ &#39;/lib/static/&#39;,
                            views_dir:  root_directory ++ &#39;/lib/views/&#39; }
    end
 
    def handle_cast(:init, state) do
        {:noreply, state}
    end
 
    def handle_call(:routes, _from, state) do
      { :reply, state.routes, state }
    end
 
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;compile and start it with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ iex -S mix 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;testing:5df44b8565d4251e584dfb856f87bd33&#34;&gt;Testing&lt;/h2&gt;

&lt;p&gt;There is ExUnit! It is a unit test framework that ships with Elixir. Let see in routing functions from the Weber:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;def on(path, controller, action) do
        [[path: path, controller: controller, action: action]]
    end
 
    def on(routesList, path, controller, action) do
        :lists.append(routesList, [[path: path, controller: controller, action: action]])
    end
 
    @doc &amp;quot;&amp;quot;&amp;quot;
      Router attribute
    &amp;quot;&amp;quot;&amp;quot;
    def otherwise(path, controller, action) do
        on(path, controller, action)
    end
 
    def otherwise(routesList, path, controller, action) do
        on(routesList, path, controller, action)
    end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now we can write unit tests for it with ExUnit:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt; test &amp;quot;Test for Weber.Route.on and Weber.Route.otherwise&amp;quot; do
      r = on(&amp;quot;/&amp;quot;, &#39;controller1&#39;, &#39;main_action&#39;)
          |&amp;gt; on(&amp;quot;/user/0xAX/add&amp;quot;, &#39;controller1&#39;, &#39;action2&#39;)
          |&amp;gt; on(&amp;quot;/user/:user/delete&amp;quot;, &#39;controller1&#39;, &#39;action2&#39;)
          |&amp;gt; otherwise(404, &#39;controller1&#39;, &#39;notfound&#39;)
    
      assert(r == [[path: &amp;quot;/&amp;quot;, controller: &#39;controller1&#39;, action: &#39;main_action&#39;], 
                   [path: &amp;quot;/user/0xAX/add&amp;quot;, controller: &#39;controller1&#39;, action: &#39;action2&#39;], 
                   [path: &amp;quot;/user/:user/delete&amp;quot;, controller: &#39;controller1&#39;, action: &#39;action2&#39;], 
                   [path: 404, controller: &#39;controller1&#39;, action: &#39;notfound&#39;]
                  ])
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;libraries:5df44b8565d4251e584dfb856f87bd33&#34;&gt;Libraries&lt;/h2&gt;

&lt;p&gt;Although Elixir is now young language, it has good set of libraries:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/guedes/exjson&#34;&gt;exjson&lt;/a&gt; - JSON parser and genarator in Elixir;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/elixir-lang/ecto&#34;&gt;ecto&lt;/a&gt; - A database wrapper and language integrated query for Elixir;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/myfreeweb/httpotion&#34;&gt;httpotion&lt;/a&gt; - The HTTP client for Elixir;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/josephwilk/amrita&#34;&gt;amrita&lt;/a&gt; - A polite, well mannered and thoroughly upstanding testing framework for Elixir;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/meh/elixir-socket&#34;&gt;elixir-socket&lt;/a&gt; - Socket wrapping for Elixir;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yrashk/genx&#34;&gt;genx&lt;/a&gt; - Elixir-style library for most important OTP functionality;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/meh/elixir-datastructures&#34;&gt;elixir-datastructures&lt;/a&gt; - Datastructures for Elixir.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;and many more. Or you of course can use any erlang libraries. Just include it to your mix.exs file as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;...
 defp deps do
    [
      {:cowboy, &amp;quot;0.8.6&amp;quot;, github: &amp;quot;extend/cowboy&amp;quot;},
      {:ecto, github: &amp;quot;elixir-lang/ecto&amp;quot;},
      {:pgsql, github: &amp;quot;ericmj/pgsql&amp;quot;, branch: &amp;quot;elixir&amp;quot;},
      {:exjson, github: &amp;quot;guedes/exjson&amp;quot;}
    ]
  end
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and execute&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mix deps.get 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the end of this post i want to say many thanks to the Elixir community which helped me all this day, you&amp;rsquo;re great!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Elixir and Cowboy</title>
      <link>http://localhost:1313/blog/2014/03/22/elixir-and-cowboy/</link>
      <pubDate>Sat, 22 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/2014/03/22/elixir-and-cowboy/</guid>
      <description>&lt;p&gt;As you can know from previous blog post i started to learn/use Elixir language for my hobby project. Elixir is programming language which built on top of Erlang virtual machine and we can use libraries which was written in Erlang. In this post i will try to tell how to use  Elixir with Cowboy web server. You can find some different examples in the Internet about usage Elixir with cowboy:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/clofresh/elixir_cowboy&#34;&gt;elixir_cowboy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dry/elixir-cowboy-example&#34;&gt;elixir-cowboy-example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ninenines/cowboy/tree/master/examples/elixir_hello_world&#34;&gt;elixir_hello_world&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/alco/ws-elixir&#34;&gt;ws-elixir&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I will tell how to use Elixir with :cowboy_static handler. First of all we must create Elixir project with mix:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mix test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;mix&lt;/code&gt; util will generate Elixir project skeleton. Now let&amp;rsquo;s make frontend part. Create priv directory in the our project root directory. And there index.html, js and css directories. I put my favorite Angular.js and bootstrap.css to the js and css directory, but you of course can use any js/css libraries which you will want. Now add simple html template:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html ng-app&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=utf-8&amp;gt;
    &amp;lt;title&amp;gt;Elixir and cowboy&amp;lt;/title&amp;gt;
    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; type=&amp;quot;text/css&amp;quot; href=&amp;quot;css/bootstrap.css&amp;quot;&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body ng-controller=&amp;quot;TestController&amp;quot;&amp;gt;
    &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-primary&amp;quot;&amp;gt;Default&amp;lt;/button&amp;gt;
    &amp;lt;ul ng-repeat=&amp;quot;n in nums&amp;quot;&amp;gt;
      &amp;lt;li&amp;gt;{{n * 2}}&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
  &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;js/angular.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;js/testJS.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And set up routing in cowboy and start it. Open &lt;code&gt;lib/testElixirWithCowboy.ex&lt;/code&gt; and add there:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;defmodule TestElixirWithCowboy do
    use Application.Behaviour
 
    def start(_type, _args) do
        dispatch = :cowboy_router.compile([
                {:_, [{&amp;quot;/css/[...]&amp;quot;, :cowboy_static, [
                        {:directory, {:priv_dir, :testElixirWithCowboy, [&amp;lt;&amp;lt;&amp;quot;public/css&amp;quot;&amp;gt;&amp;gt;]}},
                        {:mimetypes, [{&amp;lt;&amp;lt;&amp;quot;.css&amp;quot;&amp;gt;&amp;gt;, [&amp;lt;&amp;lt;&amp;quot;text/css&amp;quot;&amp;gt;&amp;gt;]}]}
                      ]},
            
                      {&amp;quot;/js/[...]&amp;quot;, :cowboy_static, [
                        {:directory, {:priv_dir, :testElixirWithCowboy, [&amp;lt;&amp;lt;&amp;quot;public/js&amp;quot;&amp;gt;&amp;gt;]}},
                        {:mimetypes, [{&amp;lt;&amp;lt;&amp;quot;.js&amp;quot;&amp;gt;&amp;gt;, [&amp;lt;&amp;lt;&amp;quot;application/javascript&amp;quot;&amp;gt;&amp;gt;]}]}
                      ]},
 
                      {&amp;quot;/[...]&amp;quot;, :cowboy_static, [
                        {:directory, {:priv_dir, :testElixirWithCowboy, [&amp;lt;&amp;lt;&amp;quot;public/&amp;quot;&amp;gt;&amp;gt;]}},
                        {:mimetypes, [{&amp;lt;&amp;lt;&amp;quot;.html&amp;quot;&amp;gt;&amp;gt;, [&amp;lt;&amp;lt;&amp;quot;text/html&amp;quot;&amp;gt;&amp;gt;]}]},
                      ]}
                     ]}
            ])
 
        {:ok, _} = :cowboy.start_http(:http, 100, [port: 8080], [env: [dispatch: dispatch]])
        TestElixirWithCowboySup.start_link
    end
    def stop(_state) do
        :ok
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And run application with executing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iex -S mix
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>