<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Haskell on 0xAX blog</title>
    <link>http://localhost:1313/categories/haskell/</link>
    <description>Recent content in Haskell on 0xAX blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 13 Jul 2014 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/haskell/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>GHCi runtime linker found a duplicate definition error</title>
      <link>http://localhost:1313/blog/2014/07/13/ghci-runtime-linker-found-a-duplicate-definition-error/</link>
      <pubDate>Sun, 13 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/2014/07/13/ghci-runtime-linker-found-a-duplicate-definition-error/</guid>
      <description>&lt;p&gt;Today I started to play with &lt;a href=&#34;https://hackage.haskell.org/package/attoparsec&#34;&gt;attoparsec&lt;/a&gt; package and tried to write simple parser. I wrote really toy data type like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;module SimpleParser where
 
import qualified Data.ByteString.Char8 as BS
import Data.Attoparsec.ByteString
 
data Str = End deriving (Show, Eq)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I tried to type:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*SimpleParser&amp;gt; End
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in ghci and will get End as I expected. Instead End I got following error:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GHCi runtime linker: fatal error: I found a duplicate definition for symbol
   _hs_bytestring_long_long_uint_hex
whilst processing object file
   /home/alex/.cabal/lib/x86_64-linux-ghc-7.6.3/bytestring-0.10.4.0/HSbytestring-0.10.4.0.o
This could be caused by:
   * Loading two different object files which export the same symbol
   * Specifying the same object file twice on the GHCi command line
   * An incorrect `package.conf&#39; entry, causing some object to be
     loaded twice.
GHCi cannot safely continue in this situation.  Exiting now.  Sorry.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we can see in error output GHCi runtime linker found duplicate definition of _hs_bytestring_long_long_uint_hex. Let&amp;rsquo;s see what&amp;rsquo;s wrong bytestring package with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cabal info bytestring
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It will give us output like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* bytestring       (library)
    Synopsis:      Fast, compact, strict and lazy byte strings with a list
                   interface
    Versions available: 0.9.0.4, 0.9.1.9, 0.9.1.10, 0.9.2.0, 0.9.2.1, 0.10.0.1,
                        0.10.0.2, 0.10.2.0, 0.10.4.0 (and 14 others)
    Versions installed: 0.10.4.0, 0.10.2.0
    Homepage:      https://github.com/haskell/bytestring
    Bug reports:   https://github.com/haskell/bytestring/issues
    Description:   An efficient compact, immutable byte string type (both strict
                   and lazy) suitable for binary or 8-bit character data.
..............................................
..............................................
..............................................
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can note that there two installed versions of bytestring package. Let&amp;rsquo;s remove old version with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo ghc-pkg unregister --force bytestring-0.10.0.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s all. After this error with GHCi runtime linker found a duplicate definition error&amp;hellip;&amp;hellip; will disappear. Hope this blog post will be useful for all who will meet error like this.&lt;/p&gt;

&lt;p&gt;Happy coding!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>My thoughts about why Haskell is not popular</title>
      <link>http://localhost:1313/blog/2014/05/11/my-thoughts-about-why-haskell-is-not-popular/</link>
      <pubDate>Sun, 11 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/2014/05/11/my-thoughts-about-why-haskell-is-not-popular/</guid>
      <description>

&lt;p&gt;Despite Haskell programming language is not young language, it has a really great and helpful community, it has big amount of libraries, unfortunately Haskell is not popular programming language. I&amp;rsquo;m not against this programming language, opposite, haskell&amp;rsquo;s unpopularity makes me sad. I will not write about haskell popularity in industry, I&amp;rsquo;ll try to explain my thoughts about &amp;ldquo;Why Haskell is not popular&amp;rdquo; not as Haskell expert, not as professional Haskell developer (i don&amp;rsquo;t get payment for Haskell programming), but from position of usual developer who started to learn/experiment with Haskell some months ago and already don&amp;rsquo;t afraid monads :). I can&amp;rsquo;t So I will try to explain my opinion about Why Haskell is not popular in this post.&lt;/p&gt;

&lt;h2 id=&#34;myths:b6b952a1303968774d34eaa0278ec9fc&#34;&gt;Myths&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;m not long time with Haskell and I don&amp;rsquo;t know all myths/stories/jokes and other funny things about Haskell, I know one popular myth (for my look it&amp;rsquo;s a myth) that Haskell is a difficult. Difficult to learn, difficult to use, not important, it is difficult. I think it&amp;rsquo;s old myth, I remember it before I started to learn Haskell. I think that it is really myth and Haskell can be not so hard as you can think about it. It is not difficult, it is different. If you&amp;rsquo;re using python,ruby,C++,javascript,java,something else&amp;hellip; Haskell will be really different. Why it is different? There are many reasons for this like: another programming paradigm, lazy evaluations, different concepts and etc&amp;hellip; But of course it is not a big problem and relatively easy to solve. Developer just need to spend more time to learn it than with another programming languages like python,javascript and etc&amp;hellip; (Except C++ of course :))&lt;/p&gt;

&lt;h2 id=&#34;lack-of-documentation:b6b952a1303968774d34eaa0278ec9fc&#34;&gt;Lack of documentation&lt;/h2&gt;

&lt;p&gt;The Lack of documentation is a first problem in this list that related with practical side of Haskell usage. I don&amp;rsquo;t mean that Haskell as language has bad documentation, it is not true. I&amp;rsquo;m speaking about Haskell libraries documentation. It&amp;rsquo;s the one of big problem that stands on the road to Haskell popularity. Sooner or later after start of Haskell learning developer will want to use libraries written in Haskell. We can easily find library by name, or functions/data types name with Hoogle, it is good, but how to use this libraries if developer doesn&amp;rsquo;t program in Haskell a couple years and library has no or has but bad documentation. For example some time ago I played with WAI and i was need in websockets. Fortunately WAI has &lt;a href=&#34;http://hackage.haskell.org/package/wai-websockets-3.0.0&#34;&gt;wai-websockets&lt;/a&gt; package but let&amp;rsquo;s look on it&amp;rsquo;s &lt;a href=&#34;http://hackage.haskell.org/package/wai-websockets-3.0.0/docs/Network-Wai-Handler-WebSockets.html&#34;&gt;documentation&lt;/a&gt;. How to use it? I don&amp;rsquo;t know how about you, but I don&amp;rsquo;t understand. I see only one way out of this: to read &lt;a href=&#34;https://github.com/yesodweb/wai/blob/master/wai-websockets/server.lhs&#34;&gt;wai-websockets&lt;/a&gt; source code or examples. Is it good? I&amp;rsquo;m not sure.&lt;/p&gt;

&lt;h2 id=&#34;standard-library:b6b952a1303968774d34eaa0278ec9fc&#34;&gt;Standard Library&lt;/h2&gt;

&lt;p&gt;Now let&amp;rsquo;s talk about Haskell&amp;rsquo;s standard library. On my look it has many really useful things for haskell and has really little amount things for Real World play. What it means when I am telling about Real World. It&amp;rsquo;s simple, i mean that Haskell standard library has many things like Control.Category, Control.Arrow, Data.Typeable and etc&amp;hellip; Again, I don&amp;rsquo;t know how is it for you, but for me and I think other newbie Haskell developers: Category, Arrow and other magic words are just words without any meaning. Not, i know Arrows, Monads are very useful in Haskell, but where is the something like Network.TcpClient, Network.HttpServer and etc&amp;hellip; I know that Haskell has separate libraries for TCP, HTTP and other network and not only network things. But imagine, for exmaple I just started with Haskell and I want to write simple example like sending HTTP request and getting response, i need to understand where to find library for this, how to install it and etc&amp;hellip; I don&amp;rsquo;t speak that Haskell standard library must have all things for all case, but things like http client in stdlib is a standard case. Or i&amp;rsquo;m wrong? Let&amp;rsquo;s look on golang for example. I think that it has a perfect standard library. Look on it and haskell standard library, do you feel difference? Golang is only five years and Haskell is 24, so big difference. Of course I have no statistic, but I see that golang is much popular for this moment. I don&amp;rsquo;t think that it is main reason but one of.&lt;/p&gt;

&lt;h2 id=&#34;why-to-learn:b6b952a1303968774d34eaa0278ec9fc&#34;&gt;Why to learn&lt;/h2&gt;

&lt;p&gt;I think it&amp;rsquo;s not only Haskell problem, but other languages too. I see only one answer for this question: To get/improve knowledges in functional programming and look on your working programming language with other eyes after it. Yes, getting new knowledges it is very good. But what about practical side? I know that somewhere developers who get money for Haskell programming, but I don&amp;rsquo;t see tons of vacancies for Haskell developers like for javascript, ruby or other tools and it is problem. Let&amp;rsquo;s look in another side. For example i want to start learn Haskell for my super-cool pet project. But why Haskell in this case? For web development I can take habitual ruby/python/php, for system programming I can take C/C++ or maybe Rust, for concurrent programming I will choose erlang. So why i need to learn new programming language and in addition so different from my standard tools?&lt;/p&gt;

&lt;h2 id=&#34;lazyness:b6b952a1303968774d34eaa0278ec9fc&#34;&gt;Lazyness&lt;/h2&gt;

&lt;p&gt;When we start to learn Haskell we can read something like this: Haskell - general purpose programming language with non-strict evaluation. I think that many developers know about lazy evaluations, but I am really not sure that all of they knows how it works, how to correctly use it and etc&amp;hellip; In this way, I as beginner in Haskell must learn not only another programming paradigm, but also another evaluation order. It is much harder, because it is much implicit. For example let&amp;rsquo;s take a look at popular ByteString library. It provides two implementations lazy strings and strict. But I still don&amp;rsquo;t know where to use first and where to use second.&lt;/p&gt;

&lt;h2 id=&#34;different-abstractions:b6b952a1303968774d34eaa0278ec9fc&#34;&gt;Different abstractions&lt;/h2&gt;

&lt;p&gt;It is problem of Haskell learning. Haskell uses different abstractions than other programming languages. And if you know python for example it will be much easy to learn ruby than Haskell. Let&amp;rsquo;s look on simple echo example. You need to read input from stdin and prtin this string again. How we do it with python language:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;import sys
data = sys.stdin.readlines()
print data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All is transparent enough. We do this task with all imperative programming languages in this way. First we reading from stdin and put result to a variable and than pass this variable to the printing function. Let&amp;rsquo;s look at the same Haskell example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;main = do
  getLine &amp;gt;&amp;gt;= putStrLn
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok. Developer can guess about getLine and putStrLn, but what is it &amp;gt;&amp;gt;=. If we open documentation we will read something like this: &amp;gt;&amp;gt;= combine two monadic values&amp;hellip; &amp;ldquo;combine two monadic values&amp;hellip;&amp;rdquo;. What is it Monad, How to use Monad and many many different questions with not easy answers sometimes. And it is only monads (concept which standard developer could not hear never), but there are many different concepts like Functors, Comonads and many many others which you can&amp;rsquo;t meet in standard programming languages.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:b6b952a1303968774d34eaa0278ec9fc&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;So it was a short list of my thoughts why Haskell is not popular. I am very interesting what do you think about Haskell popularity.
In the end I want to remind that all from this post only my opinion and if you&amp;rsquo;re agree or disagree with me write me a comment.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Reader monad understanding</title>
      <link>http://localhost:1313/blog/2014/03/04/reader-monad-understanding/</link>
      <pubDate>Tue, 04 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/2014/03/04/reader-monad-understanding/</guid>
      <description>

&lt;p&gt;Some time ago I started to learn Haskell. It&amp;rsquo;s not the first time (and event not second) that I started to learn this language. Every time I met different problems with understanding different abstractions like a Monads, Arrows, Monad Transformers and etc&amp;hellip; I think that I&amp;rsquo;m not alone with this :) But, in this time, I decided not to throw up training until I can not say: yes I can write in Haskell without pain. I started (as every time i did it) with the most popular book (for newbies) about Haskell - Learn You a Haskell and stopped at Reader monad. Spending some time I understand it (at least I think that I understand :)) and decided to share my understanding of this monad for the same newbie haskellers as me.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s imagine simple and ubiquitous case that we have application which needs in some initial configurations. Application will get configuration form configuration file, let it be conf.js with very simple structure like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  &amp;quot;username&amp;quot; : &amp;quot;0xAX&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It just has 1 &lt;code&gt;username&lt;/code&gt; key. Of course it has very little resemblance with the real application configuration, but it is not important now and enough for the example. We will read it with great Aeson library from Bryan O&amp;rsquo;Sullivan and use it in our application. Let&amp;rsquo;s start with reading configuration file content and decoding json.&lt;/p&gt;

&lt;h2 id=&#34;aeson:bce7b8a86cc9d49235884a56f18accd0&#34;&gt;Aeson&lt;/h2&gt;

&lt;p&gt;For the start we must define data type for mapping json data in it with Aeson. As you can see above, we have simple json structure with username key. So we will map this json structure to the following data type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data ConfigStructure =
  ConfigStructure {
           key1 :: String,
           key2 :: String
         } deriving(Generic)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;ConfigStructure&lt;/code&gt; has the same structure as our json, it has same fields: username. After data type creation we must read our configuration file with json data and decode it with aeson:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;configPath :: String
configPath = &amp;quot;conf.json&amp;quot;
 
getConfigContent :: IO ConfigStructure
getConfigContent = do
  configContent &amp;lt;- BSL.readFile configPath
  let Just decodedConfig = decode configContent :: Maybe ConfigStructure
  return decodedConfig
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here you can see that we reading json file with readFile function from Data.ByteString.Lazy. It has following type:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Prelude&amp;gt; import qualified Data.ByteString.Lazy as BSL
    Prelude BSL&amp;gt; :t BSL.readFile
    BSL.readFile :: FilePath -&amp;gt; IO BSL.ByteString
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where FilePath is just String. Read configuration file and get it&amp;rsquo;s content. After getting content of configuration file using Data.Aeson.decode function for decoding json data from it. After successful decoding we get Just ConfigStructure and now we can build Config data type for Reader and pass configuration file content to it.&lt;/p&gt;

&lt;h2 id=&#34;reader-monad:bce7b8a86cc9d49235884a56f18accd0&#34;&gt;Reader Monad&lt;/h2&gt;

&lt;p&gt;And now we come to the main point of this post. Main point of Reader monad to share read-only environment between couple of functions. Let&amp;rsquo;s see how Reader declared in Control.Monad.Reader:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;newtype Reader r a = Reader { runReader :: r -&amp;gt; a}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can see that it made as wrapper for runReader function with type r -&amp;gt; a where:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;r&lt;/code&gt; - is a reader which need to run and get final value from it;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt; - is an environment which need to share&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Another words we can build abstraction that will share configuration file content between different functions. Let&amp;rsquo;s see how to implement it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type Config = Reader ConfigStructure String
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we can see Config type synonym for Reader ConfigStructure String. Here ConfigStructure (see above) will be environment which we will share between functions and String return type. Now we write function for getting value of username field from configuration file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;getKeyOne :: Config
getKeyOne = do
  config &amp;lt;- ask
  return (key1 config)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see it&amp;rsquo;s pretty simple. Here is only one thing which we don&amp;rsquo;t know - ask function. ask function retrieves the monad environment. Pretty simple. Now we can get username in any place of our application with runReader function. As you can remember runReader function has following type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;runReader :: r -&amp;gt; a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where r is a reader which need to run (getKeyOne in our case) and a is environment (configuration file content in our case). Again pretty simple. We can get value of username with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- read configuration file
decodedConfig &amp;lt;- getConfigContent
-- get &amp;amp; print value of key1
putStrLn $ runReader getKeyOne $ decodedConfig
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Get function execution time in Haskell</title>
      <link>http://localhost:1313/blog/2014/01/13/get-function-execution-time-in-haskell/</link>
      <pubDate>Mon, 13 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/2014/01/13/get-function-execution-time-in-haskell/</guid>
      <description>

&lt;p&gt;Some times ago i encountered with question: How to get function execution time in Haskell program? I asked this question at &lt;a href=&#34;http://stackoverflow.com/questions/6766450/haskell-function-execution-time&#34;&gt;StackOverflow&lt;/a&gt;, and got some useful answers. Here i will try to describe how to do it. For example we have simple haskell program which will calculate sum of prime numbers which are between 0 and 10000. Something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;module TimingTest where
 
main :: IO()
main = do
	putStrLn &amp;quot;Start&amp;quot;
	putStrLn (&amp;quot;Result: &amp;quot; ++ show primesSum)
	putStrLn &amp;quot;Done&amp;quot;
 
 
--
-- Returns True if `n` is prime
--
isPrime :: Int -&amp;gt; Bool
isPrime n = null [ x | x &amp;lt;- [2..n - 1], n `mod` x  == 0]
 
primesSum :: Int
primesSum = sum [x | x &amp;lt;- [2..10000], isPrime x == True]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yes, it&amp;rsquo;s not the best implementation of prime numbers, but it&amp;rsquo;s not important at the current moment. Let&amp;rsquo;s see what we have for checking execution time.&lt;/p&gt;

&lt;h2 id=&#34;time:d75515ba84995af9bbbcc0cc417a329b&#34;&gt;Time&lt;/h2&gt;

&lt;p&gt;First of all, the simplest method to get execution time is time command. Compile our source code and execute:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ time ./TimingTest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We must get something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;real 0m3.503s
user 0m3.492s
sys 0m0.004s
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ghci:d75515ba84995af9bbbcc0cc417a329b&#34;&gt;GHCI&lt;/h2&gt;

&lt;p&gt;The second method is just add &lt;code&gt;:set +s&lt;/code&gt; in &lt;code&gt;ghci&lt;/code&gt; before the function execution. Of course it&amp;rsquo;s not the best method, because functions run much slower in `&lt;code&gt;ghci&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;timeit:d75515ba84995af9bbbcc0cc417a329b&#34;&gt;TimeIt&lt;/h2&gt;

&lt;p&gt;The third method is to use &lt;a href=&#34;http://hackage.haskell.org/package/timeit&#34;&gt;TimeIt&lt;/a&gt; haskell library by Lennart Augustsson. Very little, but useful library with simple API. It consist only from two functions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;timeIt :: IO a -&amp;gt; IO a -- | Wrap an IO computation so that it prints out the execution time
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;timeItT :: IO a -&amp;gt; IO (Double, a)Source -- | Wrap an IO computation so that it returns execution time is seconds as well as the real value.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s remake our main function as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import System.TimeIt
 
main :: IO()
main = do
 	putStrLn &amp;quot;Start&amp;quot;
	timeIt $ putStrLn (&amp;quot;Result: &amp;quot; ++ show primesSum)
	putStrLn &amp;quot;End&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and will get something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Start 
Result: 5736396
CPU time: 8.22s
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;criterion:d75515ba84995af9bbbcc0cc417a329b&#34;&gt;Criterion&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://hackage.haskell.org/package/criterion&#34;&gt;Criterion&lt;/a&gt; library provides a powerful but simple way to measure software performance by Bryan O&amp;rsquo;Sullivan. For using it, will remake again our main function as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;module Main where
 
import Criterion.Main
 
main :: IO()
main = defaultMain [
       bgroup &amp;quot;Prime numbers.&amp;quot; [bench &amp;quot;prime numbers benchmark&amp;quot; $ whnfIO (putStrLn $ show primesSum)]
       ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and as a result we will get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;estimating clock resolution...
mean is 3.760062 us (160001 iterations)
found 3006 outliers among 159999 samples (1.9%)
2461 (1.5%) high severe

estimating cost of a clock call...
mean is 98.08812 ns (28 iterations)
found 4 outliers among 28 samples (14.3%)
4 (14.3%) low severe
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>