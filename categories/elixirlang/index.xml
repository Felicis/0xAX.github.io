<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Elixirlang on 0xAX blog</title>
    <link>http://0xax.github.io/categories/elixirlang/</link>
    <description>Recent content in Elixirlang on 0xAX blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 01 Jun 2014 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://0xax.github.io/categories/elixirlang/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Using Elixir to write Ybot plugins</title>
      <link>http://0xax.github.io/blog/2014/06/01/using-elixir-to-write-ybot-plugins/</link>
      <pubDate>Sun, 01 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>http://0xax.github.io/blog/2014/06/01/using-elixir-to-write-ybot-plugins/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/OtpChatBot/Ybot&#34;&gt;Ybot&lt;/a&gt; - is a customizable bot which was inspired by GitHub&amp;rsquo;s Hubot and written with Erlang programming language. You can create pligin for Ybot in one of following languages:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Python&lt;/li&gt;
&lt;li&gt;Ruby&lt;/li&gt;
&lt;li&gt;Shell&lt;/li&gt;
&lt;li&gt;Perl&lt;/li&gt;
&lt;li&gt;Erlang/OTP&lt;/li&gt;
&lt;li&gt;Elixir&lt;/li&gt;
&lt;li&gt;Scala&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In this post i will tell you to create Ybot plugin with Elixir. For example we need to create Ybot&amp;rsquo;s plugin which will get information about commits from the Github&amp;rsquo;s repository and will send it to chat if somebody updated your repository. We will use Github API v3. For getting info about Github repository commits we must send request:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GET /repos/:owner/:repo/commits
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s create Elixir module and send request to the Github API:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;defmodule GithubCommitsNotification do
    
    @moduledoc &amp;quot;&amp;quot;&amp;quot;
        Github commits notification Ybot plugin.
    &amp;quot;&amp;quot;&amp;quot;
 
    @repo &#39;YBOT&#39;
    @author &#39;0xAX&#39;
    @github_api_url  &#39;https://api.github.com/repos/&#39; ++ @author ++ &#39;/&#39; ++ @repo ++ &#39;/commits&#39;
 
    @ybot_api_url &#39;http://localhost:8090/memories/&#39;
    @ybot_plugin_api_url &#39;http://localhost:8090/memories/?plugin=elixir_github_commits_notification&#39;
 
    :ok = :application.start :inets
    :ok = :application.start :asn1
    :ok = :application.start :crypto
    :ok = :application.start :public_key
    :ok = :application.start :ssl
 
    # Send request to the Github API
    {:ok, {_, _, body}} = :httpc.request(:get, {@github_api_url, []}, [{:ssl,[{:verify,0}]}], [])
    # parse response
    [resp | _] = JSON.parse(body)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here you can see simple Elixir module with some attributes (@repo, @author and etc&amp;hellip;), and sending http &amp;lsquo;GET&amp;rsquo; request to the Github commits API. We must get response like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;[
  {
    &amp;quot;url&amp;quot;: &amp;quot;https://api.github.com/repos/octocat/Hello-World/commits/6dcb09b5b57875f334f61aebed695e2e4193db5e&amp;quot;,
    &amp;quot;sha&amp;quot;: &amp;quot;6dcb09b5b57875f334f61aebed695e2e4193db5e&amp;quot;,
    &amp;quot;commit&amp;quot;: {
      &amp;quot;url&amp;quot;: &amp;quot;https://api.github.com/repos/octocat/Hello-World/git/commits/6dcb09b5b57875f334f61aebed695e2e4193db5e&amp;quot;,
      &amp;quot;author&amp;quot;: {
        &amp;quot;name&amp;quot;: &amp;quot;Monalisa Octocat&amp;quot;,
        &amp;quot;email&amp;quot;: &amp;quot;support@github.com&amp;quot;,
        &amp;quot;date&amp;quot;: &amp;quot;2011-04-14T16:00:49Z&amp;quot;
      },
      &amp;quot;committer&amp;quot;: {
        &amp;quot;name&amp;quot;: &amp;quot;Monalisa Octocat&amp;quot;,
        &amp;quot;email&amp;quot;: &amp;quot;support@github.com&amp;quot;,
        &amp;quot;date&amp;quot;: &amp;quot;2011-04-14T16:00:49Z&amp;quot;
      },
      &amp;quot;message&amp;quot;: &amp;quot;Fix all the bugs&amp;quot;,
      &amp;quot;tree&amp;quot;: {
        &amp;quot;url&amp;quot;: &amp;quot;https://api.github.com/repos/octocat/Hello-World/tree/6dcb09b5b57875f334f61aebed695e2e4193db5e&amp;quot;,
        &amp;quot;sha&amp;quot;: &amp;quot;6dcb09b5b57875f334f61aebed695e2e4193db5e&amp;quot;
      }
    },
    &amp;quot;author&amp;quot;: {
      &amp;quot;login&amp;quot;: &amp;quot;octocat&amp;quot;,
      &amp;quot;id&amp;quot;: 1,
      &amp;quot;avatar_url&amp;quot;: &amp;quot;https://github.com/images/error/octocat_happy.gif&amp;quot;,
      &amp;quot;gravatar_id&amp;quot;: &amp;quot;somehexcode&amp;quot;,
      &amp;quot;url&amp;quot;: &amp;quot;https://api.github.com/users/octocat&amp;quot;
    },
    &amp;quot;committer&amp;quot;: {
      &amp;quot;login&amp;quot;: &amp;quot;octocat&amp;quot;,
      &amp;quot;id&amp;quot;: 1,
      &amp;quot;avatar_url&amp;quot;: &amp;quot;https://github.com/images/error/octocat_happy.gif&amp;quot;,
      &amp;quot;gravatar_id&amp;quot;: &amp;quot;somehexcode&amp;quot;,
      &amp;quot;url&amp;quot;: &amp;quot;https://api.github.com/users/octocat&amp;quot;
    },
    &amp;quot;parents&amp;quot;: [
      {
        &amp;quot;url&amp;quot;: &amp;quot;https://api.github.com/repos/octocat/Hello-World/commits/6dcb09b5b57875f334f61aebed695e2e4193db5e&amp;quot;,
        &amp;quot;sha&amp;quot;: &amp;quot;6dcb09b5b57875f334f61aebed695e2e4193db5e&amp;quot;
      }
    ]
  }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we must get some fields from this response, like a commit&amp;rsquo;s author, commit message and etc&amp;hellip;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;# get sha
{&amp;lt;&amp;lt;&amp;quot;sha&amp;quot;&amp;gt;&amp;gt;, sha} = :lists.keyfind(&amp;lt;&amp;lt;&amp;quot;sha&amp;quot;&amp;gt;&amp;gt;, 1, resp)
 
# get author
{_, commit} = :lists.keyfind(&amp;lt;&amp;lt;&amp;quot;commit&amp;quot;&amp;gt;&amp;gt;, 1, resp)
{_, author} = :lists.keyfind(&amp;lt;&amp;lt;&amp;quot;author&amp;quot;&amp;gt;&amp;gt;, 1, commit)
{_, name} = :lists.keyfind(&amp;lt;&amp;lt;&amp;quot;name&amp;quot;&amp;gt;&amp;gt;, 1, author)
 
# get commit message
{&amp;lt;&amp;lt;&amp;quot;message&amp;quot;&amp;gt;&amp;gt;, message} = :lists.keyfind(&amp;lt;&amp;lt;&amp;quot;message&amp;quot;&amp;gt;&amp;gt;, 1, commit)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ybot has an own storage with REST API, thank you to &lt;a href=&#34;https://twitter.com/tajgur&#34;&gt;@tajgur&lt;/a&gt;. You can find documentation for it - here. And also Ybot has notifications support, in other words you can set up Ybot that it will execute your plugin by timeout and send result to you. For example you can configure Ybot that it will send to you status of your system every hour and etc&amp;hellip; We have memory API in Ybot and we can get last information about repository commits, check it, save last commit if it changed and will send update to the chat. Remeber that Ybot&amp;rsquo;s plugin must write it&amp;rsquo;s result to the &lt;code&gt;STDOUT&lt;/code&gt; in the end of execution. Here is the full source code of this plugin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;defmodule GithubCommitsNotification do
    
    @moduledoc &amp;quot;&amp;quot;&amp;quot;
        Github commits notification Ybot plugin.
    &amp;quot;&amp;quot;&amp;quot;
 
    @repo &#39;YBOT&#39;
    @author &#39;0xAX&#39;
    @github_api_url  &#39;https://api.github.com/repos/&#39; ++ @author ++ &#39;/&#39; ++ @repo ++ &#39;/commits&#39;
 
    @ybot_api_url &#39;http://localhost:8090/memories/&#39;
    @ybot_plugin_api_url &#39;http://localhost:8090/memories/?plugin=elixir_github_commits_notification&#39;
 
    :ok = :application.start :inets
    :ok = :application.start :asn1
    :ok = :application.start :crypto
    :ok = :application.start :public_key
    :ok = :application.start :ssl
 
    # Send request to the Github API
    {:ok, {_, _, body}} = :httpc.request(:get, {@github_api_url, []}, [{:ssl,[{:verify,0}]}], [])
    # parse response
    [resp | _] = JSON.parse(body)
 
    # get sha
    {&amp;lt;&amp;lt;&amp;quot;sha&amp;quot;&amp;gt;&amp;gt;, sha} = :lists.keyfind(&amp;lt;&amp;lt;&amp;quot;sha&amp;quot;&amp;gt;&amp;gt;, 1, resp)
 
    # get author
    {_, commit} = :lists.keyfind(&amp;lt;&amp;lt;&amp;quot;commit&amp;quot;&amp;gt;&amp;gt;, 1, resp)
    {_, author} = :lists.keyfind(&amp;lt;&amp;lt;&amp;quot;author&amp;quot;&amp;gt;&amp;gt;, 1, commit)
    {_, name} = :lists.keyfind(&amp;lt;&amp;lt;&amp;quot;name&amp;quot;&amp;gt;&amp;gt;, 1, author)
 
    # get commit message
    {&amp;lt;&amp;lt;&amp;quot;message&amp;quot;&amp;gt;&amp;gt;, message} = :lists.keyfind(&amp;lt;&amp;lt;&amp;quot;message&amp;quot;&amp;gt;&amp;gt;, 1, commit)
 
    result = &#39;New commit to the repo - &#39; ++ @repo ++  &#39; sha: &#39; ++ :erlang.binary_to_list(sha) ++ &#39; author: &#39; ++ :erlang.binary_to_list(name) 
             ++ &#39; message: &#39; ++ :erlang.binary_to_list(message)
 
    {:ok, {_, _, body}} = :httpc.request(:get, {@ybot_plugin_api_url, []}, [], [])
 
    case body do
        &#39;[]&#39; -&amp;gt;
            data = JSON.generate([plugin: &amp;quot;elixir_github_commits_notification&amp;quot;, 
                                  key: &amp;quot;sha&amp;quot;,
                                  value: sha])
 
            # save new record to Ybot storage
            :httpc.request(:post, {@ybot_api_url, [], &#39;application/json&#39;, data}, [], [])
            # write result to stdout
            :io.format(&amp;quot;~p~n&amp;quot;, [result])
        _ -&amp;gt;
            {_, val} = :lists.keyfind(&amp;lt;&amp;lt;&amp;quot;value&amp;quot;&amp;gt;&amp;gt;, 1, :lists.nth(1, JSON.parse(body)))
            {_, id}  = :lists.keyfind(&amp;lt;&amp;lt;&amp;quot;id&amp;quot;&amp;gt;&amp;gt;, 1, :lists.nth(1, JSON.parse(body)))
            
            cond do
                val == val -&amp;gt;
                    :io.format &amp;quot;&amp;quot;
                true -&amp;gt;
                    # delete old commit
                    :httpc.request(:delete, {@ybot_api_url ++ binary_to_list(id), []}, [], [])
                    
                    data = JSON.generate([plugin: &amp;quot;elixir_github_commits_notification&amp;quot;, 
                                          key: &amp;quot;sha&amp;quot;,
                                          value: sha])
 
                    # save new record to Ybot storage
                    :httpc.request(:post, {@ybot_api_url, [], &#39;application/json&#39;, data}, [], [])
                    # write result to stdout
                    :io.format(&amp;quot;~p~n&amp;quot;, [result])
            end
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Put this plugin to Ybot&amp;rsquo;s &lt;code&gt;notifications&lt;/code&gt; directory and set up it in configuration file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;{notification, [
    {github_commits_notification, [irc, twitter], 600}    
]},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;github_commits_notifications - plugin name&lt;/li&gt;
&lt;li&gt;[irc, twitter] - list of transports in which Ybot will send report&lt;/li&gt;
&lt;li&gt;600 - timeout in seconds&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can set up any transport which Ybot supports:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IRC&lt;/li&gt;
&lt;li&gt;XMPP&lt;/li&gt;
&lt;li&gt;Campfire&lt;/li&gt;
&lt;li&gt;HipChat&lt;/li&gt;
&lt;li&gt;Skype&lt;/li&gt;
&lt;li&gt;HTTP&lt;/li&gt;
&lt;li&gt;FlowDock&lt;/li&gt;
&lt;li&gt;SMTP&lt;/li&gt;
&lt;li&gt;Twitter&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Started to dive into elixir-lang</title>
      <link>http://0xax.github.io/blog/2014/05/10/started-to-dive-into-elixir-lang/</link>
      <pubDate>Sat, 10 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://0xax.github.io/blog/2014/05/10/started-to-dive-into-elixir-lang/</guid>
      <description>&lt;p&gt;Some times ago i decided to start new hobby project and in front of me had the task which instrument to choose for this task implementation. From the header you can guess that i decided to use Elixir. Why Elixir? The main reason is simple: I like Erlang and all it&amp;rsquo;s infrastructure, but in the same time i want to try something new and i think Elixir the best candidate for it. Now more details why i choose Elixir.&lt;/p&gt;

&lt;p&gt;First of all quote from Elixir site:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Elixir is a functional, meta-programming aware language built on top of the Erlang VM. It is a dynamic language with flexible syntax and macro support that leverages Erlang&#39;s abilities to build concurrent, distributed and fault-tolerant applications with hot code upgrades.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yes, meta-programming built on top of Erlang VM, very good start, what we have at the current moment.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Familiar to us patter matching:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; a = 5
5
iex(2)&amp;gt; 5 = a
5
iex(3)&amp;gt; list = [1,2,3]
[1, 2, 3]
iex(4)&amp;gt; [_, _, third] = list
[1, 2, 3]
iex(5)&amp;gt; third
3
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;Immutability:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;list = [1,2,3,4,5,6]
[1, 2, 3, 4, 5, 6]
iex(2)&amp;gt; list2 = [0 | list]
[0, 1, 2, 3, 4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the &lt;code&gt;list&lt;/code&gt; will never change, so it simply constructs a new list with a head of 0 and a tail of list.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Familiar and extended data types. Elixir’s built-in types are:&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;• Value types:
  – Arbitrary-sized integers
  – Floating point numbers
  – Atoms
  – Regular expressions&lt;/p&gt;

&lt;p&gt;• System types:
  – PIDs and Ports
  – References&lt;/p&gt;

&lt;p&gt;• Collection types
  – Lists
  – Tuples
  – Binaries&lt;/p&gt;

&lt;p&gt;And also: Keyword Lists, Ranges, Dictionaries, Maps and etc.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;High Order functions&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; f = :lists.map(fn elem -&amp;gt; elem * 5 end, [1,2,3,4,5])
[5, 10, 15, 20, 25]
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;The Amazing Pipes Operator&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; import Enum
nil
iex(2)&amp;gt; (1..10) |&amp;gt; map(&amp;amp;1*&amp;amp;1) |&amp;gt; filter(&amp;amp;1 &amp;lt; 40)
[1, 4, 9, 16, 25, 36]
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;Of course &lt;a href=&#34;http://www.erlang.org/doc/design_principles/users_guide.html&#34;&gt;OTP&lt;/a&gt;:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;defmodule OtpServer do
  use GenServer.Behaviour
 
  def init(current_number)
    when is_number(current_number) do
      { :ok, current_number }
    end
 
  def handle_call(:next_number, _from, current_number) do
    { :reply, current_number, current_number+1 }
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And many many more&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Elixir and Cowboy</title>
      <link>http://0xax.github.io/blog/2014/03/22/elixir-and-cowboy/</link>
      <pubDate>Sat, 22 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>http://0xax.github.io/blog/2014/03/22/elixir-and-cowboy/</guid>
      <description>&lt;p&gt;As you can know from previous blog post i started to learn/use Elixir language for my hobby project. Elixir is programming language which built on top of Erlang virtual machine and we can use libraries which was written in Erlang. In this post i will try to tell how to use  Elixir with Cowboy web server. You can find some different examples in the Internet about usage Elixir with cowboy:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/clofresh/elixir_cowboy&#34;&gt;elixir_cowboy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dry/elixir-cowboy-example&#34;&gt;elixir-cowboy-example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ninenines/cowboy/tree/master/examples/elixir_hello_world&#34;&gt;elixir_hello_world&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/alco/ws-elixir&#34;&gt;ws-elixir&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I will tell how to use Elixir with :cowboy_static handler. First of all we must create Elixir project with mix:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mix test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;mix&lt;/code&gt; util will generate Elixir project skeleton. Now let&amp;rsquo;s make frontend part. Create priv directory in the our project root directory. And there index.html, js and css directories. I put my favorite Angular.js and bootstrap.css to the js and css directory, but you of course can use any js/css libraries which you will want. Now add simple html template:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html ng-app&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=utf-8&amp;gt;
    &amp;lt;title&amp;gt;Elixir and cowboy&amp;lt;/title&amp;gt;
    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; type=&amp;quot;text/css&amp;quot; href=&amp;quot;css/bootstrap.css&amp;quot;&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body ng-controller=&amp;quot;TestController&amp;quot;&amp;gt;
    &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-primary&amp;quot;&amp;gt;Default&amp;lt;/button&amp;gt;
    &amp;lt;ul ng-repeat=&amp;quot;n in nums&amp;quot;&amp;gt;
      &amp;lt;li&amp;gt;{{n * 2}}&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
  &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;js/angular.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;js/testJS.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And set up routing in cowboy and start it. Open &lt;code&gt;lib/testElixirWithCowboy.ex&lt;/code&gt; and add there:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;defmodule TestElixirWithCowboy do
    use Application.Behaviour
 
    def start(_type, _args) do
        dispatch = :cowboy_router.compile([
                {:_, [{&amp;quot;/css/[...]&amp;quot;, :cowboy_static, [
                        {:directory, {:priv_dir, :testElixirWithCowboy, [&amp;lt;&amp;lt;&amp;quot;public/css&amp;quot;&amp;gt;&amp;gt;]}},
                        {:mimetypes, [{&amp;lt;&amp;lt;&amp;quot;.css&amp;quot;&amp;gt;&amp;gt;, [&amp;lt;&amp;lt;&amp;quot;text/css&amp;quot;&amp;gt;&amp;gt;]}]}
                      ]},
            
                      {&amp;quot;/js/[...]&amp;quot;, :cowboy_static, [
                        {:directory, {:priv_dir, :testElixirWithCowboy, [&amp;lt;&amp;lt;&amp;quot;public/js&amp;quot;&amp;gt;&amp;gt;]}},
                        {:mimetypes, [{&amp;lt;&amp;lt;&amp;quot;.js&amp;quot;&amp;gt;&amp;gt;, [&amp;lt;&amp;lt;&amp;quot;application/javascript&amp;quot;&amp;gt;&amp;gt;]}]}
                      ]},
 
                      {&amp;quot;/[...]&amp;quot;, :cowboy_static, [
                        {:directory, {:priv_dir, :testElixirWithCowboy, [&amp;lt;&amp;lt;&amp;quot;public/&amp;quot;&amp;gt;&amp;gt;]}},
                        {:mimetypes, [{&amp;lt;&amp;lt;&amp;quot;.html&amp;quot;&amp;gt;&amp;gt;, [&amp;lt;&amp;lt;&amp;quot;text/html&amp;quot;&amp;gt;&amp;gt;]}]},
                      ]}
                     ]}
            ])
 
        {:ok, _} = :cowboy.start_http(:http, 100, [port: 8080], [env: [dispatch: dispatch]])
        TestElixirWithCowboySup.start_link
    end
    def stop(_state) do
        :ok
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And run application with executing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iex -S mix
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>